<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Aloha Editor API</title>
    
    
    
    
    
    <meta property="og:title" content=""/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content=""/>
    
    <meta property="og:url" content=""/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/alohaeditor.css">
    
    
    <script>
    var config = {"monospaceLinks":true,"cleverLinks":true,"default":{"outputSourceFiles":true},"applicationName":"Aloha Editor API","disqus":"alohaeditor","googleAnalytics":"","openGraph":{"title":"","type":"website","image":"","site_name":"","url":""},"meta":{"title":"Aloha Editor API","description":"","keyword":""},"linenums":true};
    </script>
    

    
</head>
<body>
<div id="wrap" class="clearfix">
    
<div class="navigation">
    <h3 class="applicationName"><a href="index.html">Aloha Editor API</a></h3>

    <div class="search">
        <input id="search" type="text" class="form-control input-sm" placeholder="Search Documentation">
    </div>
    <ul class="list">
    
        <li class="item" data-name="arrays">
            <span class="title">
                <a href="arrays.html">arrays</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="arrays.coerce"><a href="arrays.html#coerce">coerce</a></li>
            
                <li data-name="arrays.contains"><a href="arrays.html#contains">contains</a></li>
            
                <li data-name="arrays.difference"><a href="arrays.html#difference">difference</a></li>
            
                <li data-name="arrays.equal"><a href="arrays.html#equal">equal</a></li>
            
                <li data-name="arrays.intersect"><a href="arrays.html#intersect">intersect</a></li>
            
                <li data-name="arrays.last"><a href="arrays.html#last">last</a></li>
            
                <li data-name="arrays.mapcat"><a href="arrays.html#mapcat">mapcat</a></li>
            
                <li data-name="arrays.partition"><a href="arrays.html#partition">partition</a></li>
            
                <li data-name="arrays.refill"><a href="arrays.html#refill">refill</a></li>
            
                <li data-name="arrays.some"><a href="arrays.html#some">some</a></li>
            
                <li data-name="arrays.someIndex"><a href="arrays.html#someIndex">someIndex</a></li>
            
                <li data-name="arrays.split"><a href="arrays.html#split">split</a></li>
            
                <li data-name="arrays.unique"><a href="arrays.html#unique">unique</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="blocks">
            <span class="title">
                <a href="blocks.html">blocks</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="blocks.handleBlocks"><a href="blocks.html#handleBlocks">handleBlocks</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="boundaries">
            <span class="title">
                <a href="boundaries.html">boundaries</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="boundaries.commonContainer"><a href="boundaries.html#commonContainer">commonContainer</a></li>
            
                <li data-name="boundaries.container"><a href="boundaries.html#container">container</a></li>
            
                <li data-name="boundaries.create"><a href="boundaries.html#create">create</a></li>
            
                <li data-name="boundaries.document"><a href="boundaries.html#document">document</a></li>
            
                <li data-name="boundaries.equals"><a href="boundaries.html#equals">equals</a></li>
            
                <li data-name="boundaries.fromBehindOfNode"><a href="boundaries.html#fromBehindOfNode">fromBehindOfNode</a></li>
            
                <li data-name="boundaries.fromEndOfNode"><a href="boundaries.html#fromEndOfNode">fromEndOfNode</a></li>
            
                <li data-name="boundaries.fromFrontOfNode"><a href="boundaries.html#fromFrontOfNode">fromFrontOfNode</a></li>
            
                <li data-name="boundaries.fromPosition"><a href="boundaries.html#fromPosition">fromPosition</a></li>
            
                <li data-name="boundaries.fromRange"><a href="boundaries.html#fromRange">fromRange</a></li>
            
                <li data-name="boundaries.fromRangeEnd"><a href="boundaries.html#fromRangeEnd">fromRangeEnd</a></li>
            
                <li data-name="boundaries.fromRanges"><a href="boundaries.html#fromRanges">fromRanges</a></li>
            
                <li data-name="boundaries.fromRangeStart"><a href="boundaries.html#fromRangeStart">fromRangeStart</a></li>
            
                <li data-name="boundaries.fromStartOfNode"><a href="boundaries.html#fromStartOfNode">fromStartOfNode</a></li>
            
                <li data-name="boundaries.get"><a href="boundaries.html#get">get</a></li>
            
                <li data-name="boundaries.isAtEnd"><a href="boundaries.html#isAtEnd">isAtEnd</a></li>
            
                <li data-name="boundaries.isAtStart"><a href="boundaries.html#isAtStart">isAtStart</a></li>
            
                <li data-name="boundaries.isNodeBoundary"><a href="boundaries.html#isNodeBoundary">isNodeBoundary</a></li>
            
                <li data-name="boundaries.isTextBoundary"><a href="boundaries.html#isTextBoundary">isTextBoundary</a></li>
            
                <li data-name="boundaries.jumpOver"><a href="boundaries.html#jumpOver">jumpOver</a></li>
            
                <li data-name="boundaries.next"><a href="boundaries.html#next">next</a></li>
            
                <li data-name="boundaries.nextNode"><a href="boundaries.html#nextNode">nextNode</a></li>
            
                <li data-name="boundaries.nextWhile"><a href="boundaries.html#nextWhile">nextWhile</a></li>
            
                <li data-name="boundaries.nodeAfter"><a href="boundaries.html#nodeAfter">nodeAfter</a></li>
            
                <li data-name="boundaries.nodeBefore"><a href="boundaries.html#nodeBefore">nodeBefore</a></li>
            
                <li data-name="boundaries.normalize"><a href="boundaries.html#normalize">normalize</a></li>
            
                <li data-name="boundaries.offset"><a href="boundaries.html#offset">offset</a></li>
            
                <li data-name="boundaries.prev"><a href="boundaries.html#prev">prev</a></li>
            
                <li data-name="boundaries.prevNode"><a href="boundaries.html#prevNode">prevNode</a></li>
            
                <li data-name="boundaries.prevWhile"><a href="boundaries.html#prevWhile">prevWhile</a></li>
            
                <li data-name="boundaries.range"><a href="boundaries.html#range">range</a></li>
            
                <li data-name="boundaries.raw"><a href="boundaries.html#raw">raw</a></li>
            
                <li data-name="boundaries.select"><a href="boundaries.html#select">select</a></li>
            
                <li data-name="boundaries.setRange"><a href="boundaries.html#setRange">setRange</a></li>
            
                <li data-name="boundaries.setRangeEnd"><a href="boundaries.html#setRangeEnd">setRangeEnd</a></li>
            
                <li data-name="boundaries.setRanges"><a href="boundaries.html#setRanges">setRanges</a></li>
            
                <li data-name="boundaries.setRangeStart"><a href="boundaries.html#setRangeStart">setRangeStart</a></li>
            
                <li data-name="boundaries.stepWhile"><a href="boundaries.html#stepWhile">stepWhile</a></li>
            
                <li data-name="boundaries.walkWhile"><a href="boundaries.html#walkWhile">walkWhile</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="browsers">
            <span class="title">
                <a href="browsers.html">browsers</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="browsers.chrome"><a href="browsers.html#chrome">chrome</a></li>
            
                <li data-name="browsers.safari"><a href="browsers.html#safari">safari</a></li>
            
                <li data-name="browsers.vendor"><a href="browsers.html#vendor">vendor</a></li>
            
                <li data-name="browsers.VENDOR_PREFIX"><a href="browsers.html#VENDOR_PREFIX">VENDOR_PREFIX</a></li>
            
                <li data-name="browsers.version"><a href="browsers.html#version">version</a></li>
            
                <li data-name="browsers.webkit"><a href="browsers.html#webkit">webkit</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="carets">
            <span class="title">
                <a href="carets.html">carets</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="carets.box"><a href="carets.html#box">box</a></li>
            
                <li data-name="carets.hideHint"><a href="carets.html#hideHint">hideHint</a></li>
            
                <li data-name="carets.showHint"><a href="carets.html#showHint">showHint</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="colors">
            <span class="title">
                <a href="colors.html">colors</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="colors.cross"><a href="colors.html#cross">cross</a></li>
            
                <li data-name="colors.equals"><a href="colors.html#equals">equals</a></li>
            
                <li data-name="colors.hex"><a href="colors.html#hex">hex</a></li>
            
                <li data-name="colors.rgb"><a href="colors.html#rgb">rgb</a></li>
            
                <li data-name="colors.serialize"><a href="colors.html#serialize">serialize</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="content">
            <span class="title">
                <a href="content.html">content</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="content.allowedAttributes"><a href="content.html#allowedAttributes">allowedAttributes</a></li>
            
                <li data-name="content.allowedStyles"><a href="content.html#allowedStyles">allowedStyles</a></li>
            
                <li data-name="content.allowsNesting"><a href="content.html#allowsNesting">allowsNesting</a></li>
            
                <li data-name="content.disallowedNodes"><a href="content.html#disallowedNodes">disallowedNodes</a></li>
            
                <li data-name="content.nodeTranslations"><a href="content.html#nodeTranslations">nodeTranslations</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="dom">
            <span class="title">
                <a href="dom.html">dom</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="dom.Nodes"><a href="dom.html#Nodes">Nodes</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="dom.absoluteLeft"><a href="dom.html#absoluteLeft">absoluteLeft</a></li>
            
                <li data-name="dom.absoluteTop"><a href="dom.html#absoluteTop">absoluteTop</a></li>
            
                <li data-name="dom.addClass"><a href="dom.html#addClass">addClass</a></li>
            
                <li data-name="dom.append"><a href="dom.html#append">append</a></li>
            
                <li data-name="dom.attrs"><a href="dom.html#attrs">attrs</a></li>
            
                <li data-name="dom.backward"><a href="dom.html#backward">backward</a></li>
            
                <li data-name="dom.childAndParentsUntil"><a href="dom.html#childAndParentsUntil">childAndParentsUntil</a></li>
            
                <li data-name="dom.childAndParentsUntilIncl"><a href="dom.html#childAndParentsUntilIncl">childAndParentsUntilIncl</a></li>
            
                <li data-name="dom.childAndParentsUntilInclNode"><a href="dom.html#childAndParentsUntilInclNode">childAndParentsUntilInclNode</a></li>
            
                <li data-name="dom.childAndParentsUntilNode"><a href="dom.html#childAndParentsUntilNode">childAndParentsUntilNode</a></li>
            
                <li data-name="dom.children"><a href="dom.html#children">children</a></li>
            
                <li data-name="dom.climbUntil"><a href="dom.html#climbUntil">climbUntil</a></li>
            
                <li data-name="dom.clone"><a href="dom.html#clone">clone</a></li>
            
                <li data-name="dom.cloneShallow"><a href="dom.html#cloneShallow">cloneShallow</a></li>
            
                <li data-name="dom.contains"><a href="dom.html#contains">contains</a></li>
            
                <li data-name="dom.copy"><a href="dom.html#copy">copy</a></li>
            
                <li data-name="dom.documentWindow"><a href="dom.html#documentWindow">documentWindow</a></li>
            
                <li data-name="dom.editableParent"><a href="dom.html#editableParent">editableParent</a></li>
            
                <li data-name="dom.editingHost"><a href="dom.html#editingHost">editingHost</a></li>
            
                <li data-name="dom.equals"><a href="dom.html#equals">equals</a></li>
            
                <li data-name="dom.findBackward"><a href="dom.html#findBackward">findBackward</a></li>
            
                <li data-name="dom.findForward"><a href="dom.html#findForward">findForward</a></li>
            
                <li data-name="dom.followedBy"><a href="dom.html#followedBy">followedBy</a></li>
            
                <li data-name="dom.forward"><a href="dom.html#forward">forward</a></li>
            
                <li data-name="dom.getAttr"><a href="dom.html#getAttr">getAttr</a></li>
            
                <li data-name="dom.getAttrNS"><a href="dom.html#getAttrNS">getAttrNS</a></li>
            
                <li data-name="dom.getComputedStyle"><a href="dom.html#getComputedStyle">getComputedStyle</a></li>
            
                <li data-name="dom.getComputedStyles"><a href="dom.html#getComputedStyles">getComputedStyles</a></li>
            
                <li data-name="dom.getStyle"><a href="dom.html#getStyle">getStyle</a></li>
            
                <li data-name="dom.hasAttrs"><a href="dom.html#hasAttrs">hasAttrs</a></li>
            
                <li data-name="dom.hasChildren"><a href="dom.html#hasChildren">hasChildren</a></li>
            
                <li data-name="dom.hasClass"><a href="dom.html#hasClass">hasClass</a></li>
            
                <li data-name="dom.hasText"><a href="dom.html#hasText">hasText</a></li>
            
                <li data-name="dom.insert"><a href="dom.html#insert">insert</a></li>
            
                <li data-name="dom.insertAfter"><a href="dom.html#insertAfter">insertAfter</a></li>
            
                <li data-name="dom.isContentEditable"><a href="dom.html#isContentEditable">isContentEditable</a></li>
            
                <li data-name="dom.isEditable"><a href="dom.html#isEditable">isEditable</a></li>
            
                <li data-name="dom.isEditableNode"><a href="dom.html#isEditableNode">isEditableNode</a></li>
            
                <li data-name="dom.isEditingHost"><a href="dom.html#isEditingHost">isEditingHost</a></li>
            
                <li data-name="dom.isElementNode"><a href="dom.html#isElementNode">isElementNode</a></li>
            
                <li data-name="dom.isEmptyTextNode"><a href="dom.html#isEmptyTextNode">isEmptyTextNode</a></li>
            
                <li data-name="dom.isFragmentNode"><a href="dom.html#isFragmentNode">isFragmentNode</a></li>
            
                <li data-name="dom.isSameNode"><a href="dom.html#isSameNode">isSameNode</a></li>
            
                <li data-name="dom.isTextNode"><a href="dom.html#isTextNode">isTextNode</a></li>
            
                <li data-name="dom.merge"><a href="dom.html#merge">merge</a></li>
            
                <li data-name="dom.move"><a href="dom.html#move">move</a></li>
            
                <li data-name="dom.moveAfter"><a href="dom.html#moveAfter">moveAfter</a></li>
            
                <li data-name="dom.moveBefore"><a href="dom.html#moveBefore">moveBefore</a></li>
            
                <li data-name="dom.moveNextAll"><a href="dom.html#moveNextAll">moveNextAll</a></li>
            
                <li data-name="dom.nextNonAncestor"><a href="dom.html#nextNonAncestor">nextNonAncestor</a></li>
            
                <li data-name="dom.nextSibling"><a href="dom.html#nextSibling">nextSibling</a></li>
            
                <li data-name="dom.nextSiblings"><a href="dom.html#nextSiblings">nextSiblings</a></li>
            
                <li data-name="dom.nextUntil"><a href="dom.html#nextUntil">nextUntil</a></li>
            
                <li data-name="dom.nextWhile"><a href="dom.html#nextWhile">nextWhile</a></li>
            
                <li data-name="dom.nodeAndNextSiblings"><a href="dom.html#nodeAndNextSiblings">nodeAndNextSiblings</a></li>
            
                <li data-name="dom.nodeAndPrevSiblings"><a href="dom.html#nodeAndPrevSiblings">nodeAndPrevSiblings</a></li>
            
                <li data-name="dom.nodeAtOffset"><a href="dom.html#nodeAtOffset">nodeAtOffset</a></li>
            
                <li data-name="dom.nodeIndex"><a href="dom.html#nodeIndex">nodeIndex</a></li>
            
                <li data-name="dom.nodeLength"><a href="dom.html#nodeLength">nodeLength</a></li>
            
                <li data-name="dom.normalizedNodeIndex"><a href="dom.html#normalizedNodeIndex">normalizedNodeIndex</a></li>
            
                <li data-name="dom.normalizedNthChild"><a href="dom.html#normalizedNthChild">normalizedNthChild</a></li>
            
                <li data-name="dom.normalizedNumChildren"><a href="dom.html#normalizedNumChildren">normalizedNumChildren</a></li>
            
                <li data-name="dom.nthChild"><a href="dom.html#nthChild">nthChild</a></li>
            
                <li data-name="dom.numChildren"><a href="dom.html#numChildren">numChildren</a></li>
            
                <li data-name="dom.offset"><a href="dom.html#offset">offset</a></li>
            
                <li data-name="dom.outerHtml"><a href="dom.html#outerHtml">outerHtml</a></li>
            
                <li data-name="dom.parentsUntil"><a href="dom.html#parentsUntil">parentsUntil</a></li>
            
                <li data-name="dom.parentsUntilIncl"><a href="dom.html#parentsUntilIncl">parentsUntilIncl</a></li>
            
                <li data-name="dom.prevSibling"><a href="dom.html#prevSibling">prevSibling</a></li>
            
                <li data-name="dom.prevSiblings"><a href="dom.html#prevSiblings">prevSiblings</a></li>
            
                <li data-name="dom.prevUntil"><a href="dom.html#prevUntil">prevUntil</a></li>
            
                <li data-name="dom.prevWhile"><a href="dom.html#prevWhile">prevWhile</a></li>
            
                <li data-name="dom.query"><a href="dom.html#query">query</a></li>
            
                <li data-name="dom.realFromNormalizedIndex"><a href="dom.html#realFromNormalizedIndex">realFromNormalizedIndex</a></li>
            
                <li data-name="dom.remove"><a href="dom.html#remove">remove</a></li>
            
                <li data-name="dom.removeAttr"><a href="dom.html#removeAttr">removeAttr</a></li>
            
                <li data-name="dom.removeAttrNS"><a href="dom.html#removeAttrNS">removeAttrNS</a></li>
            
                <li data-name="dom.removeAttrs"><a href="dom.html#removeAttrs">removeAttrs</a></li>
            
                <li data-name="dom.removeChildren"><a href="dom.html#removeChildren">removeChildren</a></li>
            
                <li data-name="dom.removeClass"><a href="dom.html#removeClass">removeClass</a></li>
            
                <li data-name="dom.removeShallow"><a href="dom.html#removeShallow">removeShallow</a></li>
            
                <li data-name="dom.removeStyle"><a href="dom.html#removeStyle">removeStyle</a></li>
            
                <li data-name="dom.replace"><a href="dom.html#replace">replace</a></li>
            
                <li data-name="dom.replaceShallow"><a href="dom.html#replaceShallow">replaceShallow</a></li>
            
                <li data-name="dom.scrollLeft"><a href="dom.html#scrollLeft">scrollLeft</a></li>
            
                <li data-name="dom.scrollTop"><a href="dom.html#scrollTop">scrollTop</a></li>
            
                <li data-name="dom.setAttr"><a href="dom.html#setAttr">setAttr</a></li>
            
                <li data-name="dom.setAttrNS"><a href="dom.html#setAttrNS">setAttrNS</a></li>
            
                <li data-name="dom.setStyle"><a href="dom.html#setStyle">setStyle</a></li>
            
                <li data-name="dom.stepNextUntil"><a href="dom.html#stepNextUntil">stepNextUntil</a></li>
            
                <li data-name="dom.text"><a href="dom.html#text">text</a></li>
            
                <li data-name="dom.upWhile"><a href="dom.html#upWhile">upWhile</a></li>
            
                <li data-name="dom.walk"><a href="dom.html#walk">walk</a></li>
            
                <li data-name="dom.walkRec"><a href="dom.html#walkRec">walkRec</a></li>
            
                <li data-name="dom.walkUntilNode"><a href="dom.html#walkUntilNode">walkUntilNode</a></li>
            
                <li data-name="dom.wrap"><a href="dom.html#wrap">wrap</a></li>
            
                <li data-name="dom.wrapWith"><a href="dom.html#wrapWith">wrapWith</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="dragdrop">
            <span class="title">
                <a href="dragdrop.html">dragdrop</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="dragdrop.Context"><a href="dragdrop.html#Context">Context</a></li>
            
                <li data-name="dragdrop.handleDragDrop"><a href="dragdrop.html#handleDragDrop">handleDragDrop</a></li>
            
                <li data-name="dragdrop.isDraggable"><a href="dragdrop.html#isDraggable">isDraggable</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="editables">
            <span class="title">
                <a href="editables.html">editables</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="editables.create"><a href="editables.html#create">create</a></li>
            
                <li data-name="editables.destroy"><a href="editables.html#destroy">destroy</a></li>
            
                <li data-name="editables.Editable"><a href="editables.html#Editable">Editable</a></li>
            
                <li data-name="editables.fromBoundary"><a href="editables.html#fromBoundary">fromBoundary</a></li>
            
                <li data-name="editables.fromElem"><a href="editables.html#fromElem">fromElem</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="editing">
            <span class="title">
                <a href="editing.html">editing</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="editing.attribute"><a href="editing.html#attribute">attribute</a></li>
            
                <li data-name="editing.breakline"><a href="editing.html#breakline">breakline</a></li>
            
                <li data-name="editing.className"><a href="editing.html#className">className</a></li>
            
                <li data-name="editing.copy"><a href="editing.html#copy">copy</a></li>
            
                <li data-name="editing.cut"><a href="editing.html#cut">cut</a></li>
            
                <li data-name="editing.format"><a href="editing.html#format">format</a></li>
            
                <li data-name="editing.insert"><a href="editing.html#insert">insert</a></li>
            
                <li data-name="editing.remove"><a href="editing.html#remove">remove</a></li>
            
                <li data-name="editing.style"><a href="editing.html#style">style</a></li>
            
                <li data-name="editing.unformat"><a href="editing.html#unformat">unformat</a></li>
            
                <li data-name="editing.wrap"><a href="editing.html#wrap">wrap</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="events">
            <span class="title">
                <a href="events.html">events</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="events.add"><a href="events.html#add">add</a></li>
            
                <li data-name="events.dispatch"><a href="events.html#dispatch">dispatch</a></li>
            
                <li data-name="events.hasKeyModifier"><a href="events.html#hasKeyModifier">hasKeyModifier</a></li>
            
                <li data-name="events.nextTick"><a href="events.html#nextTick">nextTick</a></li>
            
                <li data-name="events.preventDefault"><a href="events.html#preventDefault">preventDefault</a></li>
            
                <li data-name="events.remove"><a href="events.html#remove">remove</a></li>
            
                <li data-name="events.setup"><a href="events.html#setup">setup</a></li>
            
                <li data-name="events.stopPropagation"><a href="events.html#stopPropagation">stopPropagation</a></li>
            
                <li data-name="events.suppress"><a href="events.html#suppress">suppress</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="fn">
            <span class="title">
                <a href="fn.html">fn</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="fn.and"><a href="fn.html#and">and</a></li>
            
                <li data-name="fn.asMethod"><a href="fn.html#asMethod">asMethod</a></li>
            
                <li data-name="fn.comp"><a href="fn.html#comp">comp</a></li>
            
                <li data-name="fn.complement"><a href="fn.html#complement">complement</a></li>
            
                <li data-name="fn.constantly"><a href="fn.html#constantly">constantly</a></li>
            
                <li data-name="fn.extendType"><a href="fn.html#extendType">extendType</a></li>
            
                <li data-name="fn.identity"><a href="fn.html#identity">identity</a></li>
            
                <li data-name="fn.is"><a href="fn.html#is">is</a></li>
            
                <li data-name="fn.isNou"><a href="fn.html#isNou">isNou</a></li>
            
                <li data-name="fn.noop"><a href="fn.html#noop">noop</a></li>
            
                <li data-name="fn.or"><a href="fn.html#or">or</a></li>
            
                <li data-name="fn.partial"><a href="fn.html#partial">partial</a></li>
            
                <li data-name="fn.returnFalse"><a href="fn.html#returnFalse">returnFalse</a></li>
            
                <li data-name="fn.returnTrue"><a href="fn.html#returnTrue">returnTrue</a></li>
            
                <li data-name="fn.strictEquals"><a href="fn.html#strictEquals">strictEquals</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="html">
            <span class="title">
                <a href="html.html">html</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="html.hasBlockStyle"><a href="html.html#hasBlockStyle">hasBlockStyle</a></li>
            
                <li data-name="html.hasInlineStyle"><a href="html.html#hasInlineStyle">hasInlineStyle</a></li>
            
                <li data-name="html.hasLinebreakingStyle"><a href="html.html#hasLinebreakingStyle">hasLinebreakingStyle</a></li>
            
                <li data-name="html.isBlockNode"><a href="html.html#isBlockNode">isBlockNode</a></li>
            
                <li data-name="html.isGroupContainer"><a href="html.html#isGroupContainer">isGroupContainer</a></li>
            
                <li data-name="html.isGroupedElement"><a href="html.html#isGroupedElement">isGroupedElement</a></li>
            
                <li data-name="html.isHeading"><a href="html.html#isHeading">isHeading</a></li>
            
                <li data-name="html.isInlineNode"><a href="html.html#isInlineNode">isInlineNode</a></li>
            
                <li data-name="html.isListContainer"><a href="html.html#isListContainer">isListContainer</a></li>
            
                <li data-name="html.isListItem"><a href="html.html#isListItem">isListItem</a></li>
            
                <li data-name="html.isRendered"><a href="html.html#isRendered">isRendered</a></li>
            
                <li data-name="html.isTableContainer"><a href="html.html#isTableContainer">isTableContainer</a></li>
            
                <li data-name="html.isTextLevelSemanticNode"><a href="html.html#isTextLevelSemanticNode">isTextLevelSemanticNode</a></li>
            
                <li data-name="html.isUnrendered"><a href="html.html#isUnrendered">isUnrendered</a></li>
            
                <li data-name="html.isVoidNode"><a href="html.html#isVoidNode">isVoidNode</a></li>
            
                <li data-name="html.isVoidType"><a href="html.html#isVoidType">isVoidType</a></li>
            
                <li data-name="html.parse"><a href="html.html#parse">parse</a></li>
            
                <li data-name="html.prop"><a href="html.html#prop">prop</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="images">
            <span class="title">
                <a href="images.html">images</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="images.insert"><a href="images.html#insert">insert</a></li>
            
                <li data-name="images.setAttributes"><a href="images.html#setAttributes">setAttributes</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="keys">
            <span class="title">
                <a href="keys.html">keys</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="keys.ARROWS"><a href="keys.html#ARROWS">ARROWS</a></li>
            
                <li data-name="keys.CODES"><a href="keys.html#CODES">CODES</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="keys.handleKeys"><a href="keys.html#handleKeys">handleKeys</a></li>
            
                <li data-name="keys.parseKeys"><a href="keys.html#parseKeys">parseKeys</a></li>
            
                <li data-name="keys.shortcutHandler"><a href="keys.html#shortcutHandler">shortcutHandler</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="links">
            <span class="title">
                <a href="links.html">links</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="links.create"><a href="links.html#create">create</a></li>
            
                <li data-name="links.handleLinks"><a href="links.html#handleLinks">handleLinks</a></li>
            
                <li data-name="links.remove"><a href="links.html#remove">remove</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="lists">
            <span class="title">
                <a href="lists.html">lists</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="lists.format"><a href="lists.html#format">format</a></li>
            
                <li data-name="lists.toggle"><a href="lists.html#toggle">toggle</a></li>
            
                <li data-name="lists.unformat"><a href="lists.html#unformat">unformat</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="maps">
            <span class="title">
                <a href="maps.html">maps</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="maps.clone"><a href="maps.html#clone">clone</a></li>
            
                <li data-name="maps.cloneDelete"><a href="maps.html#cloneDelete">cloneDelete</a></li>
            
                <li data-name="maps.cloneSet"><a href="maps.html#cloneSet">cloneSet</a></li>
            
                <li data-name="maps.create"><a href="maps.html#create">create</a></li>
            
                <li data-name="maps.extend"><a href="maps.html#extend">extend</a></li>
            
                <li data-name="maps.fillKeys"><a href="maps.html#fillKeys">fillKeys</a></li>
            
                <li data-name="maps.filter"><a href="maps.html#filter">filter</a></li>
            
                <li data-name="maps.forEach"><a href="maps.html#forEach">forEach</a></li>
            
                <li data-name="maps.isEmpty"><a href="maps.html#isEmpty">isEmpty</a></li>
            
                <li data-name="maps.isMap"><a href="maps.html#isMap">isMap</a></li>
            
                <li data-name="maps.keys"><a href="maps.html#keys">keys</a></li>
            
                <li data-name="maps.mapTuples"><a href="maps.html#mapTuples">mapTuples</a></li>
            
                <li data-name="maps.merge"><a href="maps.html#merge">merge</a></li>
            
                <li data-name="maps.selectVals"><a href="maps.html#selectVals">selectVals</a></li>
            
                <li data-name="maps.vals"><a href="maps.html#vals">vals</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="markers">
            <span class="title">
                <a href="markers.html">markers</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="markers.extract"><a href="markers.html#extract">extract</a></li>
            
                <li data-name="markers.hint"><a href="markers.html#hint">hint</a></li>
            
                <li data-name="markers.insert"><a href="markers.html#insert">insert</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="metaview">
            <span class="title">
                <a href="metaview.html">metaview</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="metaview.toggle"><a href="metaview.html#toggle">toggle</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="mouse">
            <span class="title">
                <a href="mouse.html">mouse</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="mouse.EVENTS"><a href="mouse.html#EVENTS">EVENTS</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="mouse.handleMouse"><a href="mouse.html#handleMouse">handleMouse</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="overrides">
            <span class="title">
                <a href="overrides.html">overrides</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="overrides.nodeToState"><a href="overrides.html#nodeToState">nodeToState</a></li>
            
                <li data-name="overrides.stateToNode"><a href="overrides.html#stateToNode">stateToNode</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="overrides.consume"><a href="overrides.html#consume">consume</a></li>
            
                <li data-name="overrides.harvest"><a href="overrides.html#harvest">harvest</a></li>
            
                <li data-name="overrides.indexOf"><a href="overrides.html#indexOf">indexOf</a></li>
            
                <li data-name="overrides.joinToSet"><a href="overrides.html#joinToSet">joinToSet</a></li>
            
                <li data-name="overrides.toggle"><a href="overrides.html#toggle">toggle</a></li>
            
                <li data-name="overrides.unique"><a href="overrides.html#unique">unique</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="paste">
            <span class="title">
                <a href="paste.html">paste</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="paste.handlePaste"><a href="paste.html#handlePaste">handlePaste</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="paths">
            <span class="title">
                <a href="paths.html">paths</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="paths.fromBoundary"><a href="paths.html#fromBoundary">fromBoundary</a></li>
            
                <li data-name="paths.toBoundary"><a href="paths.html#toBoundary">toBoundary</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="searching">
            <span class="title">
                <a href="searching.html">searching</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="searching.backward"><a href="searching.html#backward">backward</a></li>
            
                <li data-name="searching.forward"><a href="searching.html#forward">forward</a></li>
            
                <li data-name="searching.search"><a href="searching.html#search">search</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="selection-change">
            <span class="title">
                <a href="selection-change.html">selection-change</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="selection-change.addHandler"><a href="selection-change.html#addHandler">addHandler</a></li>
            
                <li data-name="selection-change.handler"><a href="selection-change.html#handler">handler</a></li>
            
                <li data-name="selection-change.removeHandler"><a href="selection-change.html#removeHandler">removeHandler</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="selections">
            <span class="title">
                <a href="selections.html">selections</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="selections.Context"><a href="selections.html#Context">Context</a></li>
            
                <li data-name="selections.focus"><a href="selections.html#focus">focus</a></li>
            
                <li data-name="selections.handleSelections"><a href="selections.html#handleSelections">handleSelections</a></li>
            
                <li data-name="selections.select"><a href="selections.html#select">select</a></li>
            
                <li data-name="selections.show"><a href="selections.html#show">show</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="strings">
            <span class="title">
                <a href="strings.html">strings</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="strings.camelCaseToDashes"><a href="strings.html#camelCaseToDashes">camelCaseToDashes</a></li>
            
                <li data-name="strings.CONTROL_CHARACTER"><a href="strings.html#CONTROL_CHARACTER">CONTROL_CHARACTER</a></li>
            
                <li data-name="strings.dashesToCamelCase"><a href="strings.html#dashesToCamelCase">dashesToCamelCase</a></li>
            
                <li data-name="strings.NON_BREAKING_SPACE"><a href="strings.html#NON_BREAKING_SPACE">NON_BREAKING_SPACE</a></li>
            
                <li data-name="strings.NON_BREAKING_SPACE_CHARACTERS"><a href="strings.html#NON_BREAKING_SPACE_CHARACTERS">NON_BREAKING_SPACE_CHARACTERS</a></li>
            
                <li data-name="strings.NOT_SPACE"><a href="strings.html#NOT_SPACE">NOT_SPACE</a></li>
            
                <li data-name="strings.SPACE"><a href="strings.html#SPACE">SPACE</a></li>
            
                <li data-name="strings.TERMINAL_WHITE_SPACES"><a href="strings.html#TERMINAL_WHITE_SPACES">TERMINAL_WHITE_SPACES</a></li>
            
                <li data-name="strings.WHITE_SPACE"><a href="strings.html#WHITE_SPACE">WHITE_SPACE</a></li>
            
                <li data-name="strings.WHITE_SPACE_CHARACTERS"><a href="strings.html#WHITE_SPACE_CHARACTERS">WHITE_SPACE_CHARACTERS</a></li>
            
                <li data-name="strings.WHITE_SPACES"><a href="strings.html#WHITE_SPACES">WHITE_SPACES</a></li>
            
                <li data-name="strings.WORD_BOUNDARY"><a href="strings.html#WORD_BOUNDARY">WORD_BOUNDARY</a></li>
            
                <li data-name="strings.WORD_BOUNDARY_FROM_END"><a href="strings.html#WORD_BOUNDARY_FROM_END">WORD_BOUNDARY_FROM_END</a></li>
            
                <li data-name="strings.WORD_BREAKING_CHARACTER"><a href="strings.html#WORD_BREAKING_CHARACTER">WORD_BREAKING_CHARACTER</a></li>
            
                <li data-name="strings.WORD_BREAKING_CHARACTERS"><a href="strings.html#WORD_BREAKING_CHARACTERS">WORD_BREAKING_CHARACTERS</a></li>
            
                <li data-name="strings.ZERO_WIDTH_CHARACTERS"><a href="strings.html#ZERO_WIDTH_CHARACTERS">ZERO_WIDTH_CHARACTERS</a></li>
            
                <li data-name="strings.ZERO_WIDTH_SPACE"><a href="strings.html#ZERO_WIDTH_SPACE">ZERO_WIDTH_SPACE</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="strings.addToList"><a href="strings.html#addToList">addToList</a></li>
            
                <li data-name="strings.isControlCharacter"><a href="strings.html#isControlCharacter">isControlCharacter</a></li>
            
                <li data-name="strings.isEmpty"><a href="strings.html#isEmpty">isEmpty</a></li>
            
                <li data-name="strings.removeFromList"><a href="strings.html#removeFromList">removeFromList</a></li>
            
                <li data-name="strings.splitIncl"><a href="strings.html#splitIncl">splitIncl</a></li>
            
                <li data-name="strings.uniqueList"><a href="strings.html#uniqueList">uniqueList</a></li>
            
                <li data-name="strings.words"><a href="strings.html#words">words</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="transform">
            <span class="title">
                <a href="transform.html">transform</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="transform.html"><a href="transform.html#html">html</a></li>
            
                <li data-name="transform.msword"><a href="transform.html#msword">msword</a></li>
            
                <li data-name="transform.plain"><a href="transform.html#plain">plain</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="traversing">
            <span class="title">
                <a href="traversing.html">traversing</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="traversing.expand"><a href="traversing.html#expand">expand</a></li>
            
                <li data-name="traversing.isAtEnd"><a href="traversing.html#isAtEnd">isAtEnd</a></li>
            
                <li data-name="traversing.isAtStart"><a href="traversing.html#isAtStart">isAtStart</a></li>
            
                <li data-name="traversing.isBoundariesEqual"><a href="traversing.html#isBoundariesEqual">isBoundariesEqual</a></li>
            
                <li data-name="traversing.next"><a href="traversing.html#next">next</a></li>
            
                <li data-name="traversing.prev"><a href="traversing.html#prev">prev</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="typing">
            <span class="title">
                <a href="typing.html">typing</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="typing.actions"><a href="typing.html#actions">actions</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="typing.handleTyping"><a href="typing.html#handleTyping">handleTyping</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="undo">
            <span class="title">
                <a href="undo.html">undo</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="undo.capture"><a href="undo.html#capture">capture</a></li>
            
                <li data-name="undo.close"><a href="undo.html#close">close</a></li>
            
                <li data-name="undo.Context"><a href="undo.html#Context">Context</a></li>
            
                <li data-name="undo.enter"><a href="undo.html#enter">enter</a></li>
            
                <li data-name="undo.leave"><a href="undo.html#leave">leave</a></li>
            
                <li data-name="undo.redo"><a href="undo.html#redo">redo</a></li>
            
                <li data-name="undo.undo"><a href="undo.html#undo">undo</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
    </ul>
</div>
    <div class="main">
        <h1 class="page-title" data-filename="undo.js.html">Source: undo.js</h1>
        


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** undo.js is part of Aloha Editor project http://aloha-editor.org
 *
 * Aloha Editor is a WYSIWYG HTML5 inline editing library and editor.
 * Copyright (c) 2010-2013 Gentics Software GmbH, Vienna, Austria.
 * Contributors http://aloha-editor.org/contribution.php
 * @namespace undo
 */
define([
	'arrays',
	'maps',
	'dom',
	'mutation',
	'boundaries',
	'functions',
	'ranges',
	'content', // Hack for require-proto
	'traversing' // Hack for require-proto
], function (
	Arrays,
	Maps,
	Dom,
	Mutation,
	Boundaries,
	Fn,
	Ranges,
	__hack1__,
	__hack2__
) {
	'use strict';

	// Deprecated functions from assert.js

	function assertEqual(a, b) {
		if (a !== b) {
			throw Error('assertion error ' + a + ' !== ' + b);
		}
	}

	function assertNotEqual(a, b) {
		if (a === b) {
			throw Error('assertion error ' + a + ' === ' + b);
		}
	}

	function assertFalse(value) {
		assertEqual(value, false);
	}

	function assertTrue(value) {
		assertEqual(value, true);
	}

	function assertError() {
		throw Error();
	}

	// Deprecated functions from boundaries.js

	function beforeNodeBoundary(node) {
		return [node.parentNode, Dom.nodeIndex(node)];
	}

	function nodeAtBoundary(boundary) {
		return Dom.nodeAtOffset(boundary[0], boundary[1]);
	}

	function nodeBeforeBoundary(boundary) {
		boundary = Boundaries.normalize(boundary);
		if (!Boundaries.isNodeBoundary(boundary)) {
			return boundary[0];
		}
		return Boundaries.isAtStart(boundary) ? null : Dom.nthChild(boundary[0], boundary[1] - 1);
	}

	function nodeAfterBoundary(boundary) {
		boundary = Boundaries.normalize(boundary);
		if (!Boundaries.isNodeBoundary(boundary)) {
			return boundary[0].nextSibling;
		}
		return Boundaries.isAtEnd(boundary) ? null : Dom.nthChild(boundary[0], boundary[1]);
	}

	function precedingTextLength(boundary) {
		boundary = Boundaries.normalize(boundary);
		var node = nodeBeforeBoundary(boundary);
		var len = 0;
		if (!Boundaries.isNodeBoundary(boundary)) {
			len += boundary[1];
			node = node.previousSibling;
		}
		while (node &amp;&amp; Dom.isTextNode(node)) {
			len += Dom.nodeLength(node);
			node = node.previousSibling;
		}
		return len;
	}

	/**
	 * Creates a new undo context.
	 *
	 * The undo context holds an assortment of data items used across
	 * many of the undo functions.
	 *
	 * Should be treated as a black box.
	 *
	 * @param elem {Element}
	 *        The element whose mutations are to be observed and made
	 *        undoable/redoable.
	 * @param opts {Object.&lt;string,*>}
	 *        A map of options:
	 *        noMutationObserver - whether or not to use the MutationObserver
	 *          API to observe changes,
	 *        maxCombineChars - how many character to combine to a
	 *          single change (default 20).
	 *        maxHistory - how many items to keep in the history
	 *          (default 1000).
	 * @return {Undo}
	 * @memberOf undo
	 */
	function Context(elem, opts) {
		opts = Maps.merge({
			maxCombineChars: 20,
			maxHistory: 1000
		}, opts);
		var context = {
			elem: elem,
			observer: null,
			stack: [],
			frame: null,
			opts: opts,
			history: [],
			historyIndex: 0
		};
		context.observer = (!opts.noMutationObserver &amp;&amp; window.MutationObserver
		                    ? ChangeObserverUsingMutationObserver()
		                    : ChangeObserverUsingSnapshots());
		return context;
	}

	/**
	 * Creates a changeSet.
	 *
	 * @param meta {*} the metadat of the changeSet
	 * @param changes {Array.&lt;Change>} an array of changes
	 * @param selection {RangeUpdateChange} reflects the change of the
	 *        range from before to after all changes in this changeSet.
	 * @return {ChangeSet}
	 */
	function makeChangeSet(meta, changes, selection) {
		return {
			changes: changes,
			meta: meta,
			selection: selection
		};
	}

	/**
	 * Whether two paths are equal.
	 *
	 * @param pathA {Path}
	 * @param pathB {Path}
	 * @return {boolean}
	 */
	function pathEquals(pathA, pathB) {
		return Arrays.equal(pathA, pathB, Arrays.equal);
	}

	function stepDownPath(path, containerName, off) {
		path.push([off, containerName]);
	}

	/**
	 * Creates a path from the given container down to the given node.
	 *
	 * @param container {Element}
	 * @param container {Node}
	 * @return {Path}
	 */
	function nodePath(container, node) {
		var path = [];
		while (node &amp;&amp; container !== node) {
			var parent = node.parentNode;
			if (!parent) {
				return [];
			}
			stepDownPath(path, parent.nodeName, Dom.normalizedNodeIndex(node));
			node = parent;
		}
		path.reverse();
		return path;
	}

	/**
	 * Creates a boundary from the given path in the given container.
	 *
	 * @param container {Element} at which the path begins.
	 * @param path {Path} which goes down from the given container to the boundary.
	 * @return {Boundary} the boundary at the given path.
	 */
	function boundaryFromPath(container, path) {
		for (var i = 0; i &lt; path.length - 1; i++) {
			var step = path[i];
			assertEqual(step[1], container.nodeName);
			container = Dom.normalizedNthChild(container, step[0]);
		}
		var lastStep = Arrays.last(path);
		var off = lastStep[0];
		container = Dom.nextWhile(container, Dom.isEmptyTextNode);
		// NB: container must be non-null at this point.
		assertEqual(lastStep[1], container.nodeName);
		if (Dom.isTextNode(container)) {
			// Because text offset paths with value 0 are invalid.
			assertNotEqual(off, 0);
			while (off > Dom.nodeLength(container)) {
				assertTrue(Dom.isTextNode(container));
				off -= Dom.nodeLength(container);
				container = container.nextSibling;
			}
			// Because we may have stepped out of a text node.
			if (!Dom.isTextNode(container)) {
				assertEqual(off, 0);
				container = container.parentNode;
				off = Dom.nodeIndex(container);
			}
		} else {
			off = Dom.realFromNormalizedIndex(container, off);
		}
		return Boundaries.normalize([container, off]);
	}

	function endOfNodePath(container, node) {
		var path = nodePath(container, node);
		var numChildren = Dom.normalizedNumChildren(node);
		stepDownPath(path, node.nodeName, numChildren);
		return path;
	}

	/**
	 * Creates a path from a boundary.
	 *
	 * A path is an array of arrays where each member represents the
	 * offset of a child in a parent. The empty array represents the
	 * path of the top-most container from which the path was
	 * calculated.
	 *
	 * Only the last step in a path may be the offset in a text node.
	 *
	 * If the nodes before a boundary are text nodes, the last step will
	 * always be the offset in a text node, and the combined length of
	 * the text nodes before the boundary will be used as the
	 * offset. This is true even if the node following the boundary is
	 * not a text node, and the path could theoretically be represented
	 * by the next node's offset in the element parent. That's because
	 * the path represents the path in the DOM based on the normalized
	 * number of previous siblings, and doesn't depend on any next
	 * siblings, and if we didn't always include the text offset before
	 * the path, the path would look different if constructed from a DOM
	 * that is structurally equal before the boundary, but contains text
	 * nodes directly after the boundary.
	 *
	 * Paths with textOff = 0 are invalid because empty text nodes
	 * should be treated as if they are not present and if a path in an
	 * empty text node is taken, the same path would become invalid when
	 * the empty text node is removed. This is true even when the text
	 * node is not empty because we can't depend on what occurs after
	 * the boundary (see previous paragraph).
	 *
	 * Paths reflect the normalized DOM - offsets will be calculated
	 * assuming that empty text nodes don't exist and that subsequent
	 * text nodes are counted as one.
	 *
	 * @param container {Element}
	 *        The container from which to start calculating the path.
	 *        Must contain the given boundary.
	 * @param boundary {Boundary}
	 *        Must be contained by the given container
	 * @return {Path}
	 *        The path from the given container to the given boundary.
	 */
	function pathFromBoundary(container, boundary) {
		boundary = Boundaries.normalize(boundary);
		var path;
		var textOff = precedingTextLength(boundary);
		if (textOff) {
			var node = nodeBeforeBoundary(boundary);
			// Because nodePath() would use the normalizedNodeIndex
			// which would translate an empty text node after a
			// non-empty text node to the normalized offset after the
			// non-empty text node.
			node = Dom.prevWhile(node, Dom.isEmptyTextNode);
			path = nodePath(container, node);
			stepDownPath(path, '#text', textOff);
		} else if (Boundaries.isAtEnd(boundary)) {
			path = endOfNodePath(container, boundary[0]);
		} else {
			path = nodePath(container, nodeAfterBoundary(boundary));
		}
		return path;
	}

	/**
	 * Useful for when the path to be generated should only represent a
	 * fragment of a complete path, and mustn't include the last step,
	 * which may otherwise be a text container (which must only occur as
	 * the last step of a path and can't therefore be composed).
	 */
	function incompletePathFromBoundary(container, boundary) {
		boundary = Boundaries.normalize(boundary);
		var node = nodeAfterBoundary(boundary);
		// Because if the boundary is between two text nodes, index
		// normalization performed by nodePath() will use the offset of
		// the previous text node, while an incomplete path must point
		// to the normalized index of the next element node.
		if (precedingTextLength(boundary)) {
			node = Dom.nextWhile(node, Dom.isTextNode);
		}
		var path;
		if (node) {
			path = nodePath(container, node);
		} else {
			path = endOfNodePath(container, boundary[0]);
		}
		return path;
	}

	/**
	 * Create a path from the given container to immediately before the
	 * given node.
	 */
	function pathBeforeNode(container, node) {
		return pathFromBoundary(container, beforeNodeBoundary(node));
	}

	function recordRange(container, range) {
		if (!range) {
			return null;
		}
		var start = pathFromBoundary(container, Boundaries.fromRangeStart(range));
		var end = pathFromBoundary(container, Boundaries.fromRangeEnd(range));
		return start &amp;&amp; end ? {start: start, end: end} : null;
	}

	function takeRecords(context, frame) {
		if (frame.opts.noObserve) {
			context.observer.discardChanges();
		} else {
			var changes = context.observer.takeChanges();
			if (changes.length) {
				frame.records.push({changes: changes});
			}
		}
	}

	function partitionRecords(context, leavingFrame, lowerFrame, upperFrame) {
		if ((upperFrame.opts.partitionRecords &amp;&amp; !upperFrame.opts.noObserve)
		    || (!!lowerFrame.opts.noObserve !== !!upperFrame.opts.noObserve)) {
			takeRecords(context, leavingFrame);
		}
	}

	/**
	 * This function is missing documentation.
	 * @TODO Complete documentation.
	 *
	 * @memberOf undo
	 */
	function close(context) {
		if (context.frame) {
			context.observer.disconnect();
			context.frame = null;
		}
	}

	/**
	 * Enters a new frame in the given undo context.
	 * 
	 * @param context {Undo}
	 * @param opts {Object.&lt;string,*>}
	 *        A map of options:
	 *        noObserve - whether to observe changes. If true, changes
	 *          must be supplied via the result argument of leave().
	 *          Applies recursively to all nested frames.
	 *        partitionRecords - whether to split up changes happening
	 *          inside this frame and frames direcly below this frame (but
	 *          not deeper).
	 *        oldRange - a range to record that reflects the range
	 *          before any changes in this frame happen.
	 * @return {void}
	 * @memberOf undo
	 */
	function enter(context, opts) {
		opts = opts || {};
		var upperFrame = context.frame;
		var observer = context.observer;
		var elem = context.elem;
		var noObserve = opts.noObserve || (upperFrame &amp;&amp; upperFrame.opts.noObserve);
		var frame = {
			opts: Maps.merge(opts, {noObserve: noObserve}),
			records: [],
			oldRange: recordRange(elem, opts.oldRange),
			newRange: null
		};
		if (upperFrame) {
			partitionRecords(context, upperFrame, frame, upperFrame);
			context.stack.push(upperFrame);
		} else {
			observer.observeAll(elem);
		}
		context.frame = frame;
	}

	/**
	 * Leave a frame in the given undo context.
	 *
	 * @param context {Undo}
	 * @param result {Object.&lt;...string>}
	 * @return {Frame}
	 * @memberOf undo
	 */
	function leave(context, result) {
		var frame = context.frame;
		var upperFrame = context.stack.pop();
		if (upperFrame) {
			partitionRecords(context, frame, frame, upperFrame);
		} else {
			takeRecords(context, frame);
			close(context);
		}
		var noObserve = frame.opts.noObserve;
		// Because we expect either a result to be returned by the
		// capture function, or observed by the observer, but not both.
		assertFalse(!!(!noObserve &amp;&amp; result &amp;&amp; result.changes));
		if (noObserve &amp;&amp; result &amp;&amp; result.changes &amp;&amp; result.changes.length) {
			frame.records.push({changes: result.changes});
		}
		frame.newRange = recordRange(context.elem, result &amp;&amp; result.newRange);
		if (upperFrame) {
			upperFrame.records.push({frame: frame});
			context.frame = upperFrame;
		}
		return frame;
	}

	/**
	 * Enter/leave a frame before/after calling the given function.
	 *
	 * @param context {Undo}
	 * @param opts {Object.&lt;string,*>} given as the opts argument to enter()
	 * @param {function(void):{Object.&lt;string,*>}} given as the result argument to leave()
	 * @return {Frame} the captured frame
	 * @memberOf undo
	 */
	function capture(context, opts, fn) {
		enter(context, opts);
		var result;
//		try {
			result = fn();
//		} catch (e) {
			// TODO for some reason, whether I rethrow here or if I
			// remove the catch (but not the try{}finally{}) completely,
			// my version of Chrome just ignores the exception. Maybe
			// it's a bug that just happens in the version of Chrome I'm
			// using?
//			window.console &amp;&amp; window.console.log(e);
//			throw e;
//		} finally {
			return leave(context, result);
//		}
	}

	function captureOffTheRecord(context, opts, fn) {
		var frame = capture(context, Maps.merge(opts, {noObserve: true}), fn);
		// Because leave() will push the captured frame onto the
		// upperFrame.
		var upperFrame = context.frame;
		if (upperFrame) {
			upperFrame.records.pop();
		}
		return frame;
	}

	function makeInsertDeleteChange(type, path, content) {
		return {
			type: type,
			path: path,
			content: content
		};
	}

	function makeInsertChange(path, content) {
		return makeInsertDeleteChange('insert', path, content);
	}

	function makeDeleteChange(path, content) {
		return makeInsertDeleteChange('delete', path, content);
	}

	function makeUpdateAttrChange(path, node, recordAttrs) {
		var attrs = [];
		Maps.forEach(recordAttrs, function (attr) {
			var name = attr.name;
			var ns = attr.ns;
			attrs.push({
				name: name,
				ns: ns,
				oldValue: attr.oldValue,
				newValue: Dom.getAttrNS(node, ns, name)
			});
		});
		return {
			type: 'update-attr',
			path: path,
			attrs: attrs
		};
	}

	function makeRangeUpdateChange(oldRange, newRange) {
		return {
			type: 'update-range',
			oldRange: oldRange,
			newRange: newRange
		};
	}

	var INSERT = 0;
	var UPDATE_ATTR = 1;
	var UPDATE_TEXT = 2;
	var DELETE_FLAG = 4;
	var DELETE = DELETE_FLAG;
	var COMPOUND_DELETE = DELETE_FLAG + 1;

	function makeDelete(node, target, prevSibling) {
		return {
			type: DELETE,
			node: node,
			target: target,
			prevSibling: prevSibling,
			contained: [],
			updateAttr: null,
			updateText: null
		};
	}

	function makeMultiDelete(delRecords, target, prevSibling) {
		return {
			type: COMPOUND_DELETE,
			records: delRecords,
			target: target,
			prevSibling: prevSibling
		};
	}

	function makeInsert(node) {
		return {type: INSERT, node: node, contained: []};
	}

	function makeUpdateAttr(node, attrs) {
		return {type: UPDATE_ATTR, node: node, attrs: {}};
	}

	function makeUpdateText(node, oldValue) {
		return {type: UPDATE_TEXT, node: node, oldValue: oldValue};
	}

	// NB: All insert-delete sequences in this table are no-ops:
	// insert-delete               => no-op
	// insert-delete-insert        => insert (in inserted)
	// insert-delete-insert-delete => no-op
	// delete-insert               => move   (in delsBy*, inserted)
	// delete-insert-delete        => delete (in delsBy*)
	// delete-insert-delete-insert => move   (in delsBy*, inserted)
	function normalizeInsertDeletePreserveAnchors(moves, inserted, delsByPrevSibling, delsByTarget) {
		moves.forEach(function (move) {
			var node = move.node;
			var id = Dom.ensureExpandoId(node);
			var type = move.type;
			if (DELETE === type) {
				var prevSibling = move.prevSibling;
				var target = move.target;
				var ref = prevSibling ? prevSibling : target;
				var map = prevSibling ? delsByPrevSibling : delsByTarget;
				var refId = Dom.ensureExpandoId(ref);
				var dels = map[refId] = map[refId] || [];

				if (inserted[id]) {
					// Because an insert-delete sequence will become a
					// no-op, and we just pretend that it didn't happen.
					delete inserted[id];
				} else {
					dels.push(move);
				}

				// Because it may be that the deleted node is the
				// prevSibling reference of a previous delete.
				var delsHavingRefs = delsByPrevSibling[id];
				if (delsHavingRefs) {
					delete delsByPrevSibling[id];
					// Because by eliminating delete-inserts above we
					// may have eliminated the first delete in the
					// delete sequence that must have a valid anchor.
					if (!dels.length &amp;&amp; delsHavingRefs.length) {
						var refDel = delsHavingRefs[0];
						refDel.prevSibling = prevSibling;
						refDel.target = target;
					}
					map[refId] = dels.concat(delsHavingRefs);
				}
			} else if (INSERT === type) {
				assertFalse(!!inserted[id]);
				inserted[id] =  move;
			} else {
				// NB: moves should only contains INSERTs and DELETEs
				// (not COMPOUND_DELETEs).
				assertError();
			}
		});
	}

	function records(record) {
		return (COMPOUND_DELETE === record.type) ? record.records : [record];
	}

	function insertFollowedByDelete(recordA, recordB) {
		var prevB = recordB.prevSibling;
		var targetB = recordB.target;
		var node = recordA.node;
		if (prevB) {
			if (prevB === node || Dom.contains(prevB, node)) {
				return true;
			}
			// TODO Dom.contains(node, prevB) probably not needed
			return !Dom.followedBy(prevB, node) &amp;&amp; !Dom.contains(node, prevB);
		} else {
			if (targetB === node || Dom.contains(targetB, node)) {
				return false;
			}
			// TODO Dom.contains(node, prevB) probably not needed
			return !Dom.followedBy(targetB, node) &amp;&amp; !Dom.contains(node, targetB);
		}
	}

	function insertFollowedByInsert(recordA, recordB) {
		return Dom.followedBy(recordA.node, recordB.node);
	}
	
	function prevSiblingFollowedByDelete(prevA, recordB) {
		var prevB = recordB.prevSibling;
		var targetB = recordB.target;
		if (prevB) {
			if (Dom.contains(prevB, prevA)) {
				return true;
			}
			if (Dom.contains(prevA, prevB)) {
				return false;
			}
			return Dom.followedBy(prevA, prevB);
		} else {
			if (prevA === targetB) {
				return false;
			}
			if (Dom.contains(targetB, prevA) || Dom.contains(prevA, targetB)) {
				return false;
			}
			return Dom.followedBy(prevA, targetB);
		}
	}

	function deleteFollowedByDelete(recordA, recordB) {
		var prevA = recordA.prevSibling;
		var prevB = recordB.prevSibling;
		var targetA = recordA.target;
		var targetB = recordB.target;
		if (prevA) {
			return prevSiblingFollowedByDelete(prevA, recordB);
		} else if (prevB) {
			return !prevSiblingFollowedByDelete(prevB, recordA);
		} else {
			return Dom.followedBy(targetA, targetB);
		}
	}

	function compareRecords(recordA, recordB) {
		var deleteA = (DELETE_FLAG &amp; recordA.type);
		var deleteB = (DELETE_FLAG &amp; recordB.type);
		var follows;
		if (deleteA &amp;&amp; deleteB) {
			follows = deleteFollowedByDelete(recordA, recordB);
		} else if (!deleteA &amp;&amp; !deleteB) {
			follows = insertFollowedByInsert(recordA, recordB);
		} else if (!deleteA &amp;&amp; deleteB) {
			follows = insertFollowedByDelete(recordA, recordB);
		} else if (deleteA &amp;&amp; !deleteB) {
			follows = !insertFollowedByDelete(recordB, recordA);
		}
		return follows ? -1 : 1;
	}

	function sortRecordTree(tree) {
		tree.sort(compareRecords);
		tree.forEach(function (record) {
			records(record).forEach(function (record) {
				if (record.contained &amp;&amp; (DELETE_FLAG &amp; record.type)) {
					sortRecordTree(record.contained);
				}
			});
		});
	}

	function fillOutContained(container, recs) {
		var index = {};
		recs.forEach(function (record) {
			records(record).forEach(function (record) {
				var type = record.type;
				if (!(type &amp; DELETE_FLAG) &amp;&amp; type !== INSERT) {
					return;
				}
				var id = Dom.ensureExpandoId(record.node);
				// NB The same node may have one insert and one or more
				// deletes. It may have more than one delete because it
				// may have been inserted in a not-observed element, and
				// then removed again from it after the not-observed
				// element was inserted itself.
				var containerRecords = index[id] || [];
				containerRecords.push(record);
				index[id] = containerRecords;
			});
		});
		var containerId = Dom.ensureExpandoId(container);
		assertFalse(!!index[containerId]);
		var containerInsert = makeInsert(container);
		index[containerId] = [containerInsert];
		recs.forEach(function (record) {
			var target = ((DELETE &amp; record.type)
			              ? record.target
			              : record.node.parentNode);
			var ancestor = Dom.upWhile(target, function (ancestor) {
				return !index[Dom.ensureExpandoId(ancestor)];
			});
			if (!ancestor) {
				return;
			}
			var containerRecords = index[Dom.ensureExpandoId(ancestor)];
			containerRecords.forEach(function (containerRecord) {
				containerRecord.contained.push(record);
			});
		});
		return containerInsert.contained;
	}

	function makeRecordTree(container, moves, updateAttr, updateText) {
		var delsByPrevSibling = {};
		var delsByTarget = {};
		var inserted = {};
		normalizeInsertDeletePreserveAnchors(moves, inserted, delsByPrevSibling, delsByTarget);
		var delss = Maps.vals(delsByPrevSibling).concat(Maps.vals(delsByTarget));
		// Because normalizeInsertDeletePreserveAnchors may cause empty
		// del arrays.
		delss = delss.filter(function (dels) {
			return dels.length;
		});
		function consumeUpdates(record) {
			var id = Dom.ensureExpandoId(record.node);
			if (DELETE === record.type) {
				record.updateAttr = updateAttr[id];
				record.updateText = updateText[id];
			}
			delete updateAttr[id];
			delete updateText[id];
		}
		var dels = delss.map(function (dels){
			var refDel = dels[0];
			dels.forEach(consumeUpdates);
			return makeMultiDelete(dels, refDel.target, refDel.prevSibling);
		});
		var inss = Maps.vals(inserted);
		inss.forEach(consumeUpdates);
		var tree = fillOutContained(
			container,
			dels.concat(inss)
				.concat(Maps.vals(updateAttr))
				.concat(Maps.vals(updateText))
		);
		sortRecordTree(tree);
		return tree;
	}

	function delPath(container, delRecord, incomplete) {
		var prevSibling = delRecord.prevSibling;
		var path;
		var boundary;
		if (prevSibling) {
			var off = Dom.nodeIndex(prevSibling) + 1;
			boundary = [prevSibling.parentNode, off];
			path = (incomplete
			        ? incompletePathFromBoundary(container, boundary)
			        : pathFromBoundary(container, boundary));
		} else {
			var target = delRecord.target;
			boundary = [target, 0];
			path = (incomplete
			        ? incompletePathFromBoundary(container, boundary)
			        : pathFromBoundary(container, boundary));
		}
		return path;
	}

	function reconstructNodeFromDelRecord(delRecord) {
		var node = delRecord.node;
		var reconstructedNode;
		if (Dom.isTextNode(node)) {
			var updateText = delRecord.updateText;
			if (updateText) {
				reconstructedNode = node.ownerDocument.createTextNode(updateText.oldValue);
			} else {
				reconstructedNode = Dom.clone(node);
			}
		} else {
			reconstructedNode = Dom.clone(node);
			var updateAttr = delRecord.updateAttr;
			if (updateAttr) {
				Maps.forEach(updateAttr.attrs, function (attr) {
					Dom.setAttrNS(reconstructedNode, attr.ns, attr.name, attr.oldValue);
				});
			}
		}
		return reconstructedNode;
	}

	function generateChanges(containerPath, container, changes, recordTree) {
		var lastInsertContent = null;
		var lastInsertNode = null;
		recordTree.forEach(function (record) {
			var type = record.type;
			var path;
			var node;
			if (COMPOUND_DELETE === type) {
				lastInsertNode = null;
				path = containerPath.concat(delPath(container, record));
				var parentPath = containerPath.concat(delPath(container, record, true));
				var lastDeleteContent = null;
				record.records.forEach(function (record) {
					var contained = record.contained;
					if (contained.length) {
						generateChanges(parentPath, record.node, changes, contained);
						lastDeleteContent = null;
					}
					var delNode = reconstructNodeFromDelRecord(record);
					if (lastDeleteContent) {
						lastDeleteContent.push(delNode);
					} else {
						lastDeleteContent = [delNode];
						changes.push(makeDeleteChange(path, lastDeleteContent));
					}
				});
			} else if (INSERT === type) {
				node = record.node;
				path = containerPath.concat(pathBeforeNode(container, node));
				if (lastInsertNode &amp;&amp; lastInsertNode === node.previousSibling) {
					lastInsertContent.push(Dom.clone(node));
				} else {
					lastInsertContent = [Dom.clone(node)];
					changes.push(makeInsertChange(path, lastInsertContent));
				}
				lastInsertNode = node;
			} else if (UPDATE_ATTR === type) {
				lastInsertNode = null;
				node = record.node;
				path = containerPath.concat(pathBeforeNode(container, node));
				changes.push(makeUpdateAttrChange(path, node, record.attrs));
			} else if (UPDATE_TEXT === type) {
				lastInsertNode = null;
				node = record.node;
				path = containerPath.concat(pathBeforeNode(container, node));
				changes.push(makeDeleteChange(path, [node.ownerDocument.createTextNode(record.oldValue)]));
				changes.push(makeInsertChange(path, [Dom.clone(node)]));
			} else {
				// NB: only COMPOUND_DELETEs should occur in a recordTree,
				// DELETEs should not except as part of a COMPOUND_DELETE.
				assertError();
			}
		});
	}

	function changesFromMutationRecords(container, records) {
		var updateAttr = {};
		var updateText = {};
		var moves = [];
		records.forEach(function (record) {
			var target = record.target;
			var oldValue = record.oldValue;
			var type = record.type;
			var id;
			if ('attributes' === type) {
				var name = record.attributeName;
				var ns = record.attributeNamespace;
				id = Dom.ensureExpandoId(target);
				var updateAttrRecord = updateAttr[id] = updateAttr[id] || makeUpdateAttr(target, {});
				var attrs = updateAttrRecord.attrs;
				var attr = {oldValue: oldValue, name: name, ns: ns};
				var key = name + ' ' + ns;
				attrs[key] = attrs[key] || attr;
			} else if ('characterData' === type) {
				id = Dom.ensureExpandoId(target);
				updateText[id] = updateText[id] || makeUpdateText(target, oldValue);
			} else if ('childList' === type) {
				var prevSibling = record.previousSibling;
				Arrays.coerce(record.removedNodes).forEach(function (node) {
					moves.push(makeDelete(node, target, prevSibling));
				});
				Arrays.coerce(record.addedNodes).forEach(function (node) {
					moves.push(makeInsert(node));
				});
			} else {
				assertError();
			}
		});
		var recordTree = makeRecordTree(container, moves, updateAttr, updateText);
		var changes = [];
		var rootPath = [];
		generateChanges(rootPath, container, changes, recordTree);
		return changes;
	}

	function changesFromSnapshots(before, after) {
		var path = [];
		stepDownPath(path, after.nodeName, 0);
		var changes = [];
		// NB: We don't clone the children because a snapshot is
		// already a copy of the actual content and is supposed to
		// be immutable.
		changes.push(makeDeleteChange(path, Dom.children(before)));
		changes.push(makeInsertChange(path, Dom.children(after)));
		return changes;
	}

	function ChangeObserverUsingMutationObserver() {
		var observedElem = null;
		var pushedRecords = [];
		var observer = new MutationObserver(function (records) {
			pushedRecords = pushedRecords.concat(records);
		});

		function observeAll(elem) {
			var observeAllFlags = {
				'childList': true,
				'attributes': true,
				'characterData': true,
				'subtree': true,
				'attributeOldValue': true,
				'characterDataOldValue': true
			};
			observer.observe(elem, observeAllFlags);
			observedElem = elem;
		}

		function takeChanges() {
			var records =  pushedRecords.concat(observer.takeRecords());
			pushedRecords.length = 0;
			return changesFromMutationRecords(observedElem, records);
		}

		function disconnect() {
 			observedElem = null;
			pushedRecords.length = 0;
			observer.disconnect();
			observer = null;
		}

		return {
			observeAll: observeAll,
			takeChanges: takeChanges,
			discardChanges: takeChanges,
			disconnect: disconnect
		};
	}

	function ChangeObserverUsingSnapshots() {
		var observedElem = null;
		var beforeSnapshot = null;

		function observeAll(elem) {
			observedElem = elem;
			beforeSnapshot = Dom.clone(elem);
		}

		function takeChanges() {
			if (Dom.isEqualNode(beforeSnapshot, observedElem)) {
				return [];
			}
			var before = beforeSnapshot;
			var after = Dom.clone(observedElem);
			beforeSnapshot = after;
			return changesFromSnapshots(before, after);
		}

		// TODO instead of discarding the snapshot and making a new one,
		// we could accept the changes that were generated instead and
		// apply them to the snapshot, which would be faster for big
		// documents.
		function discardChanges() {
			beforeSnapshot = Dom.clone(observedElem);
		}

		function disconnect() {
			observedElem = null;
			beforeSnapshot = null;
		}

		return {
			observeAll: observeAll,
			takeChanges: takeChanges,
			discardChanges: discardChanges,
			disconnect: disconnect
		};
	}

	function applyChange(container, change, range, ranges, textNodes) {
		var type = change.type;
		var boundary;
		var node;
		var parent;
		if ('update-attr' === type) {
			boundary = boundaryFromPath(container, change.path);
			node = nodeAfterBoundary(boundary);
			change.attrs.forEach(function (attr) {
				Dom.setAttrNS(node, attr.ns, attr.name, attr.newValue);
			});
		} else if ('update-range' === type) {
			var newRange = change.newRange;
			if (range &amp;&amp; newRange) {
				var startBoundary = boundaryFromPath(container, newRange.start);
				var endBoundary = boundaryFromPath(container, newRange.end);
				Boundaries.setRange(range, startBoundary, endBoundary);
			}
		} else if ('insert' === type) {
			boundary = boundaryFromPath(container, change.path);
			change.content.forEach(function (node) {
				var insertNode = Dom.clone(node);
				if (Dom.isTextNode(insertNode)) {
					textNodes.push(insertNode);
				}
				boundary = Mutation.insertNodeAtBoundary(insertNode, boundary, true, ranges);
			});
		} else if ('delete' === type) {
			boundary = boundaryFromPath(container, change.path);
			boundary = Mutation.splitBoundary(boundary, ranges);
			node = nodeAtBoundary(boundary);
			parent = node.parentNode;
			change.content.forEach(function (removedNode) {
				var next;
				if (Dom.isTextNode(removedNode)) {
					var removedLen = Dom.nodeLength(removedNode);
					while (removedLen) {
						assertEqual(node.nodeName, removedNode.nodeName);
						var len = Dom.nodeLength(node);
						if (removedLen >= len) {
							next = node.nextSibling;
							Mutation.removePreservingRanges(node, ranges);
							removedLen -= len;
							node = next;
						} else {
							boundary = Mutation.splitBoundary([node, removedLen], ranges);
							var nodeBeforeSplit = nodeBeforeBoundary(boundary);
							var nodeAfterSplit = nodeAfterBoundary(boundary);
							Mutation.removePreservingRanges(nodeBeforeSplit, ranges);
							removedLen = 0;
							textNodes.push(nodeAfterSplit);
							node = nodeAfterSplit;
						}
					}
				} else {
					next = node.nextSibling;
					assertEqual(node.nodeName, removedNode.nodeName);
					Mutation.removePreservingRanges(node, ranges);
					node = next;
				}
			});
		} else {
			assertError();
		}
	}

	function applyChanges(container, changes, ranges) {
		var textNodes = [];
		changes.forEach(function (change) {
			applyChange(container, change, null, ranges, textNodes);
		});
		textNodes.forEach(function (node) {
			Mutation.joinTextNode(node, ranges);
		});
	}

	function applyChangeSet(container, changeSet, range, ranges) {
		applyChanges(container, changeSet.changes, ranges);
		if (range &amp;&amp; changeSet.selection) {
			applyChange(container, changeSet.selection, range, ranges, []);
		}
	}

	function inverseChange(change) {
		var type = change.type;
		var inverse;
		if ('update-attr' === type) {
			inverse = Maps.merge(change, {
				attrs: change.attrs.map(function (attr) {
					return Maps.merge(attr, {oldValue: attr.newValue, newValue: attr.oldValue});
				})
			});
		} else if ('update-range' === type) {
			inverse = Maps.merge(change, {
				oldRange: change.newRange,
				newRange: change.oldRange
			});
		} else if ('insert' === type) {
			inverse = Maps.merge(change, {type: 'delete'});
		} else if ('delete' === type) {
			inverse = Maps.merge(change, {type: 'insert'});
		} else {
			assertError();
		}
		return inverse;
	}

	function inverseChangeSet(changeSet) {
		var changes = changeSet.changes.slice(0).reverse().map(inverseChange);
		return makeChangeSet(changeSet.meta, changes, inverseChange(changeSet.selection));
	}

	function collectChanges(context, frame) {
		var collectedChanges = [];
		frame.records.forEach(function (record) {
			var changes;
			var nestedFrame = record.frame;
			if (nestedFrame) {
				changes = collectChanges(context, nestedFrame);
			} else {
				changes = record.changes;
			}
			collectedChanges = collectedChanges.concat(changes);
		});
		return collectedChanges;
	}

	function changeSetFromFrameHavingChanges(context, frame, changes) {
		var rangeUpdateChange = makeRangeUpdateChange(frame.oldRange, frame.newRange);
		return makeChangeSet(frame.opts.meta, changes, rangeUpdateChange);
	}

	/**
	 * Given a frame, creates a changeSet from it.
	 *
	 * @param context {Undo}
	 * @param frame {Frame}
	 * @return {ChangeSet}
	 */
	function changeSetFromFrame(context, frame) {
		var changes = collectChanges(context, frame);
		return changeSetFromFrameHavingChanges(context, frame, changes);
	}

	function partitionedChangeSetsFromFrame(context, frame) {
		var changeSets = [];
		frame.records.forEach(function (record) {
			var changeSet;
			var nestedFrame = record.frame;
			if (nestedFrame) {
				var changes = collectChanges(context, nestedFrame);
				changeSet = changeSetFromFrameHavingChanges(context, nestedFrame, changes);
			} else {
				changeSet = changeSetFromFrameHavingChanges(context, frame, record.changes);
			}
			changeSets.push(changeSet);
		});
		return changeSets;
	}

	function combineChanges(oldChangeSet, newChangeSet, opts) {
		var oldChanges = oldChangeSet.changes;
		var newChanges = newChangeSet.changes;
		if (!oldChanges.length || !newChanges.length) {
			return null;
		}
		var oldType = oldChangeSet.meta &amp;&amp; oldChangeSet.meta.type;
		var newType = newChangeSet.meta &amp;&amp; newChangeSet.meta.type;
		// TODO combine enter as the first character of a sequence of
		// text inserts (currently will return null below because we
		// only handle text boundaries).
		if (!(('typing' === oldType || 'enter' === oldType)
		      &amp;&amp; 'typing' === newType)) {
			return null;
		}
		var oldChange = oldChanges[0];
		var newChange = newChanges[0];
		var oldPath = oldChange.path;
		var newPath = newChange.path;
		var oldStep = Arrays.last(oldPath);
		var newStep = Arrays.last(newPath);
		// Because the text inserts may have started at a node boundary
		// but we expect text steps below, we'll just pretend they
		// started at the start of a text node.
		if (oldStep &amp;&amp; '#text' !== oldStep[1]) {
			oldStep = ['#text', 0];
			oldPath = oldPath.concat([oldStep]);
		}
		if (oldChange.type !== 'insert'
		    || oldChange.type !== newChange.type
		    || oldStep[1] !== '#text'
		    || oldStep[1] !== newStep[1]
		    || 1 !== oldChange.content.length
		    || 1 !== newChange.content.length
		    || !Dom.isTextNode(oldChange.content[0])
		    || !Dom.isTextNode(newChange.content[0])
		    || opts.maxCombineChars &lt;= Dom.nodeLength(oldChange.content[0])
		    || oldStep[0] + Dom.nodeLength(oldChange.content[0]) !== newStep[0]
		    || !pathEquals(oldPath.slice(0, oldPath.length - 1),
		                   newPath.slice(0, newPath.length - 1))) {
			return null;
		}
		var combinedNode = Dom.clone(oldChange.content[0]);
		combinedNode.insertData(Dom.nodeLength(combinedNode), newChange.content[0].data);
		var insertChange = makeInsertChange(oldPath, [combinedNode]);
		var oldRange = oldChangeSet.selection.oldRange;
		var newRange = newChangeSet.selection.newRange;
		var rangeUpdateChange = makeRangeUpdateChange(oldRange, newRange);
		return makeChangeSet(oldChangeSet.meta, [insertChange], rangeUpdateChange);
	}

	/**
	 * Generates changeSets from the records in the current frame in the
	 * given context, empties the frame's records, and adds the
	 * changeSets to the history.
	 *
	 * The current frame should have the partitionRecords option set to
	 * true and must be a top-level frame (not a nested frame).
	 *
	 * If the current history index is not at the end of the current
	 * history, for example due to an undo, all changes after the
	 * current index will be dropped.
	 *
	 * @param context {Undo}
	 * @return {void}
	 */
	function advanceHistory(context) {
		assertFalse(!!context.stack.length);
		var history = context.history;
		var historyIndex = context.historyIndex;
		var frame = context.frame;
		takeRecords(context, frame);
		var newChangeSets = partitionedChangeSetsFromFrame(context, frame);
		if (!newChangeSets.length) {
			return;
		}
		history.length = historyIndex;
		var lastChangeSet = Arrays.last(history);
		if (1 === newChangeSets.length &amp;&amp; lastChangeSet &amp;&amp; !context.interrupted) {
			var combinedChangeSet = combineChanges(lastChangeSet, newChangeSets[0], context.opts);
			if (combinedChangeSet) {
				history.pop();
				newChangeSets = [combinedChangeSet];
			}
		}
		context.interrupted = false;
		history = history.concat(newChangeSets);
		var maxHistory = context.opts.maxHistory;
		if (history.length > maxHistory) {
			history = history.slice(history.length - maxHistory, history.length);
		}
		frame.records = [];
		context.history = history;
		context.historyIndex = history.length;
	}

	/**
	 * Undoes the last changeSet in the history and decreases the
	 * history index.
	 *
	 * @param context {Undo}
	 * @param range {Range} will be set to the recorded range before the
	 *        changes in the changeSet occurred.
	 * @param ranges {Array.&lt;Range>} will be preserved.
	 * @return {void}
	 * @memberOf undo
	 */
	function undo(context, range, ranges) {
		advanceHistory(context);
		var history = context.history;
		var historyIndex = context.historyIndex;
		if (!historyIndex) {
			return;
		}
		historyIndex -= 1;
		var changeSet = history[historyIndex];
		var undoChangeSet = inverseChangeSet(changeSet);
		captureOffTheRecord(context, {meta: {type: 'undo'}}, function () {
			applyChangeSet(context.elem, undoChangeSet, range, ranges);
		});
		context.historyIndex = historyIndex;
	}

	/**
	 * Redoes a previously undone changeSet in the history and
	 * increments the history index.
	 *
	 * @param context {Undo}
	 * @param range {Range} will be set to the recorded range after the
	 *        changes in the changeSet occurred.
	 * @param ranges {Array.&lt;Range>} will be preserved.
	 * @return {void}
	 * @memberOf undo
	 */
	function redo(context, range, ranges) {
		advanceHistory(context);
		var history = context.history;
		var historyIndex = context.historyIndex;
		if (historyIndex === history.length) {
			return;
		}
		var changeSet = history[historyIndex];
		historyIndex += 1;
		captureOffTheRecord(context, {meta: {type: 'redo'}}, function () {
			applyChangeSet(context.elem, changeSet, range, ranges);
		});
		context.historyIndex = historyIndex;
	}

	return {
		Context: Context,
		enter: enter,
		close: close,
		leave: leave,
		capture: capture,
		pathFromBoundary: pathFromBoundary,
		changeSetFromFrame: changeSetFromFrame,
		inverseChangeSet: inverseChangeSet,
		applyChangeSet: applyChangeSet,
		advanceHistory: advanceHistory,
		makeInsertChange: makeInsertChange,
		undo: undo,
		redo: redo
	};
});
</code></pre>
        </article>
    </section>






        
        <!-- disqus code -->
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'alohaeditor'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            <!-- // disqus code -->
        

        <footer>
            Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha10</a> on Thu Nov 06 2014 11:30:57 GMT+0100 (CET)
        </footer>
    </div>
</div>
<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script src="scripts/main.js"></script>
<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
 (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-17460389-2', 'auto'); ga('require', 'displayfeatures'); ga('send', 'pageview');</script>
</body>
</html>
