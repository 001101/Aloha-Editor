<h1></h1>
<div><div class="hero-unit center"><h1>Module: <span style="color:#08C;">trees</span>
</h1>
</div>
<h2 id="treewalkingfunctions">Tree walking functions.</h3>

<p>prewalk(form, fn, inplace)</p>

<pre><code>Descend into the given form, which is a tree of arrays andmaps
(javascript Object), and build a new tree with the result of
applying the given fn to each branch and leaf. Only arrays and
maps are descended into, everything else is considered a leaf.

The given fn is applied as the tree is descended into - the
function application (pre)cedes descending into the tree.

By default, an entirely new structure is returned. If the
optional inplace argument is true, the algorithm will not
allocate any new structures, but modify the given form in-place.
The benefit of this is more performance due to less allocation,
and reduced memory overhead, but see the "Note" below.
</code></pre>

<p>postwalk(form, fn, inplace)</p>

<pre><code>the same as prewalk, except the given fn is applied as the tree
is ascended.
</code></pre>

<p>preprune(form, pred, inplace)</p>

<pre><code>the same as prewalk, except pred is a predicate function and any
branch or leaf that is encountered and for which pred returns
true is removed from the tree.
</code></pre>

<p>postprune(form, pred, inplace)</p>

<pre><code>the same as preprune, except the predicate function is applied as
the tree is ascended.

Postpruning is potentially slower than prepruning since it always
descendes into the whole tree, even into pruned nodes, while
prepruning skips any pruned nodes.
</code></pre>

<p>leaves(form, leaf, inplace)</p>

<pre><code>Like postwalk, except the leaf function is applied only to
leaves, and not to the arrays or maps that make up the tree
structure of form.

Useful when one is only interested in tranforming leaves.
</code></pre>

<p>flatten(form)</p>

<pre><code>Makes an array of all of the given form's leaves.
</code></pre>

<p>clone(form)</p>

<pre><code>Constructs a deep clone of the given form.
</code></pre>

<p>prepruneDom(form, pred, inplace)</p>

<pre><code>Like preprune() except:

- the given form may be either an element or other DOM node, and
  only elements are descended into, all other node types are
  considered leaves.

- the given form will be cloned before it is being traversed, unless
  inplace is true.

  This is different from prewalk, where the subforms that are
  passed to fn are not clones. Making a deep clone first
  simplifies some things, basically because an array or map can
  be the child of multiple arrays and maps at the same time,
  while a node can only be the child of a single parent node at
  any one time.
</code></pre>

<p>postpruneDom(form, pred, inplace)</p>

<pre><code>Like prepruneDom(), except the given function is applied as the tree
is ascended.
</code></pre>

<p>walk(form, recurse, inplace)</p>

<pre><code>If form is an array or map, calls recurse on each of its items.
If inplace is true, modifies the form and sets each item to the
result of the call to recurse. If inplace is false, creates a new
array/map containing the results of calling recurse. Returns
either form if inplace is true, or the newly created array/map.

If form is not an array or map, it is simply returned.

An example using walk() in a custom recursive traversal function:

function doSomething(root) {
    function step(form) {
        form = Trees.walk(form, step);
        // do something with form
        return form ? [form] : [];
    }
    return step(root)[0] || null;
}
</code></pre>

<p>walk(form, recurse)</p>

<pre><code>Short for walk(form, recurse, true)
</code></pre>

<p>walkDomInplace(form, recurse)</p>

<pre><code>Similar to walk() but operates on DOM nodes.

Elements are considered non-leaf, and everything else is
considerd a leaf.
</code></pre>

<p>Note: All functions work on array+map trees, unless they are suffixed
      with Dom, in which case they only work on DOM nodes.</p>

<p>Note: When walking arrays and maps, if the fn and leaf functions
      modify the parent or any ancestor of the passed form, the
      resulting behaviour is undefined. Only modification of the
      passed form and descendants of the passed form is valid.</p>

<pre><code>  During DOM traversal, it is allowed to insert-into/remove-from
  the children of the parent of the given form, as long the given
  form itself is not removed.
</code></pre>

<p>Note: the algorithms are recursive and the maximum nesting level of
      the input set is therefore bound to the maximum stack depth.
      IE7 and IE8 for example have a maximum stack depth of greater
      than 1000, so the maximum input nesting level should not exceed
      about 300 (3 stack frames are needed per nesting level).</p></div>
