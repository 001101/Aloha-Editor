h2. The Block Plugin

After reading this guide, you will be able to:

* TODO

endprologue.

WARNING: This guide is currently work-in-progress.


h3. What are Aloha Blocks?

*Aloha Blocks* (Blocks) are non-editable areas of a website, which often have
some properties being editable through the Aloha user interface.

Some use cases for blocks include:

* Displaying a vCard of a person from an address book as a paragraph inside
  an editable, where the person can be chosen through the Aloha UI
* Display a custom "inline image" in continuous text, which could float either left or right,
  and where the image caption is again changeable using Aloha
* Show a listing of news inside or outside an editable.

Some properties of blocks:

* Blocks can occur inside or outside of Aloha Editables
* Both +<span>+ and +<div>+ elements can be blockified (i.e. converted to blocks)
* can contain nested editable areas
* can be copy/pasted and dragged/dropped if they are inside an Aloha editable


h3. Enabling the Block Plugin

Aloha Blocks are implemented as a plugin called @block@, which is part of the @common@ bundle.

Furthermore, you need to load the @paste@ plugin. Thus, just add +common/block,common/paste+ to the @data-aloha-plugins@ loading list.

WARNING: As the @contenthandler@ plugin currently cleans up the HTML very rigidly, this can interfere with blocks. If you use them together, make sure to test thoroughly that no unwanted HTML is removed.

h4. Initializing  Blocks

Blocks need to be initialized before they can be used. Most conveniently, it should be done when the page is loaded. The most simple way to initialize a block is by using the +.alohaBlock()+ function on a jQuery collection, i.e. to make @.vcard@ a block, just use @jQuery('.vcard').alohaBlock()@.

TIP: Make sure to wrap the initialization code inside an @Aloha.ready()@ callback, to make
     sure Aloha is fully loaded by then.

NOTE: It is only allowed to convert @span@ or @div@ elements into an Aloha Block. Otherwise,
      an error will be thrown. So watch the browser's console output when debugging!

The @alohaBlock@ function takes a configuration object of *Block Attributes*, which are set on the block.

h4. Block Attributes

Each block can have multiple *block attributes*, which are like configuration parameters and can influence the rendering of blocks. A block attribute key is only allowed to be lowercase, and shall contain only @a-z, 0-9, -@ and @_@ in the name. The block attribute value must be a string:

<javascript>
// Valid block attributes
{
	key: 'value',
	_foo: 'bar',
	'my-special-attr': 'Yeah',
	'attr-09': 'Test some very long string',
	another: '{"json": "encoded as string"}'
}
// Invalid block attributes
{
	kEy: 'value'
	foo: false,
	bar: {
		json: "foo"
	}
}
</javascript>

NOTE: Because block attributes are stored as @data@ attributes on the block DOM node, we must be
      quite restrictive concerning the allowed keys, and only allow string values.

Block attributes can be set at construction time through +.alohaBlock(attrs)+ or using the +block.attr()+ function at runtime.

All block attributes which start with +aloha-block-+ are *internal* and can *only* be set during construction time.

h4. Block Types

One special block attribute is called +aloha-block-type+, which must be set to one of the block types registered at the @BlockManager@. It can be only set during construction time, and if it is not set, the @DefaultBlock@ is automatically chosen.

Depending on the block type, a different @Block@ class is being instanciated. Later, you will be introduced in writing your own block type.

TIP: Aloha shows configuration errors on the firebug or webkit console; so watch this place
     for any errors, f.e. because block types were not found.

h4. Block Attribute Overriding Sources

When calling @.alohaBlock@ on an element, the following data is merged together:

* @{ aloha-block-type: 'DefaultBlock' }@
* The block attributes specified in the @.alohaBlock(attr)@ function
* All @data-@ attributes on the corresponding DOM node.

That is, if a DOM node which should be blockified has a @data-aloha-block-type@ property, this one is always used. Else, the @aloha-block-type@ property from the @.alohaBlock()@ function is used (if given). If nothing is specified, the @DefaultBlock@ is used.

The same is done for all block attributes, not only @aloha-block-type@.

h4. Default Settings

Block construction such as the following is very common:

<javascript>
Aloha.ready(function() {
	Aloha.jQuery('.foo').alohaBlock({
		'aloha-block-type': 'MySpecialBlock'
	});
	Aloha.jQuery('.bar').alohaBlock({
		'aloha-block-type': 'DebugBlock'
	});
});
</javascript>

To make such initialization code more easy to write and more declarative, this can be also written inside the Aloha settings:

<javascript>
Aloha.settings.plugins.block.defaults {
	'.foo': {
		'aloha-block-type': 'MySpecialBlock'
	},
	'.bar': {
		'aloha-block-type': 'DebugBlock'
	}
}
</javascript>

Using Aloha settings is the preferred way of initialization, as it is more easy to read.

h3. Interacting with Blocks

After a block has been initialized, it can be retrieved through the +BlockManager.getBlock()+ method. This method accepts a variety of arguments:

* the ID of the block (as in @<span id="....">@)
* the DOM element of the block
* the jQuery object of the block

Thus, the following is all possible and returns the same @Block@ object instance:

<javascript>
require(['block/blockmanager'], function(BlockManager) {
	var b1 = BlockManager.getBlock('myBlock'); // ID
	var b2 = BlockManager.getBlock(jQuery('#myBlock')); // jQuery object
	var b3 = BlockManager.getBlock(jQuery('#myBlock').get(0)); // DOM object
});
</javascript>

After you retrieved a block instance, you can use the public API of it. The most important
methods are:

* +attr(key, value)+ to set @key@ to @value@
* +attr({key1: value1, key2: value2})+ to set multiple values simultaneously
* +attr(key)+ to retrieve the value for @key@
* +attr()+ to retrieve all key/values as objecz
* +activate()+ to activate the block
* +deactivate()+ to deactivate the block

When an attribute is changed through @attr@, the block is re-rendered automatically.

h3. Writing a Custom Aloha Block

When writing a custom block, you should do so in your own *aloha plugin*.
Inside the *plugin module*, you need to register the Aloha Blocks at the
Block Manager. An example skeleton follows:

<javascript filename="blockdemo/lib/blockdemo-plugin.js">
define([
	'aloha/plugin',
	'block/blockmanager',
	'blockdemo/block'
], function(Plugin, BlockManager, block) {
	"use strict";
	return Plugin.create('blockdemo', {
		init: function() {
			BlockManager.registerBlockType('MyCustomBlock', block.MyCustomBlock);
		}
	});
});
</javascript>
<javascript filename="blockdemo/lib/block.js">
define([
	'block/block'
], function(block) {
	var MyCustomBlock = block.AbstractBlock.extend({
		// ... your custom code here ...
	});

	return {
		MyCustomBlock: MyCustomBlock
	};
});
</javascript>

Now, you can implement the main API of the block, as explained in the next section.

h4. Initialization and Rendering API

The first method you can override is the +init($element)+ method. There, you get the jQuery @$element@ as argument, and can use it to register f.e. custom event handlers or initialize the block contents. Furthermore, you can set block attributes using the @attr()@ method if needed.

After the +init()+ method, the @$element@ is *augumented* by additional DOM nodes, which are needed f.e. for the drag/drop handles of the block.

The second place you will most certainly override is the +update($element, postProcessFn)+ method. This method is called always when one or multiple block attributes changed, so you are able to run any code you want inside there, manipulating @$element@.

In some use cases, you will want to do some asynchronous work inside the @update()@ method, like fetching an updated rendering of the element via AJAX from the server side. That is the reason of the @postProcessFn@ callback function you get as second method argument: This function must be *always called* after the @$element@ has been modified, as it renders the drag/drop handles if necessary.

Because we add some special DOM nodes to the @$element@ (for displaying the drag/drop handles for example), you should not rely on stuff like the number of child elements of @$element@. If you still need to do this, make sure to filter out all elements which have an +aloha-block-handle+ CSS class applied (as they are internal elements).

h4. Custom Block Handles

If you wish to write custom block handles, e.g. for deleting a block or adding new blocks, you need to override the +renderBlockHandlesIfNeeded+ method. There, you can add DOM nodes to @this.$element@, and style them as handles using CSS.

There are two rules to follow:

* First, the method must be *idempotent*, that is, it needs to have the same behavior
  no matter how often it is called. This means f.e. that if this method inserts a drag handle,
  it is only allowed to do so if the drag handle is not yet inserted.
* Second, the method must mark all DOM nodes which are added with the CSS class
  +aloha-block-handle+ such that they are marked as internal.

The default block handles function looks as follows, rendering a drag handle:

<javascript>
renderBlockHandlesIfNeeded: function() {
	if (this.isDraggable()) {
		if (this.$element.find('.aloha-block-draghandle').length == 0) {
			this.$element.prepend('<span class="aloha-block-handle aloha-block-draghandle"></span>');
		}
	}
}
</javascript>

h4. Nested Aloha Editables

If you want to mark a certain area inside a block as aloha editable again, you just need to apply the +aloha-editable+ CSS class to it. If the default behavior is not what you want, you can also call @$element.find(...).aloha()@ in the @init()@ and/or @update()@ method.

h4. Editing API

* getSchema() getTitle() explained
* disabling sidebar
* Custom Floating Menu?

h3. Writing custom editor

* TODO explain

h3. Connecting Blocks to Backend system


h3. APIs and Extension Points

* Writing custom Blocks
* Writing custom Editors

h3. Internals

h3. Browser Compatibility Matrix

|_.                                             |_. Firefox 7|_. Chrome 17|_. IE7 |_. IE8 |_. IE9 |_. Unit Test Written|
|_. General Aloha                               |  ✓         |  ✓         |  ✓    | ✓     | ✓     |     ✓              |
|_. General Blocks                              |  ✓         |  ✓         |  ✓    | ✓     | ✓     |     ✓              |
|_. Drag & Drop of inline elements              |  ✓         |  ✓         | (✓) only works sometimes   | ✓     | ✓     |     ✓              |
|_. Drag & Drop of block-level elements         |  ✓         |  ✓         |  ✓    | ✓     | ✓     |     ✘              |
|_. Copy & Paste                                |  ✓         |  ✓         |  ✘ browser always dies on second copy/paste    | ✓     | ✓     |     ✓              |
|_. Cut & Paste                                 |  ✓         |  ✓         |  ✘ browser always dies on second copy/paste    | ✓     | ✓     |     ✓              |
|_. Deletion of single blocks (block-level)     |  ✓         |  ✓         |  ✘ always jumps to top of page| (✓) TODO selection issues, sometimes jumps to top of page| ✓     |      ✘              |
|_. Deletion of single blocks (inline)          |  ✓         |  ✓         |  ✓    | ✓     | ✓     |      ✘              |
|_. Deletion of blocks being part of selection  |  ✓         |  ✓         |  ✓    | ✓     | ✓     |      ✘              |
|_. Caret handling of inline blocks             |  ✘         |  ✘         |  ✘    | ✘     | ✘     |      ✘              |


h3. Changelog

* July 7, 2011: Initial version by "Sebastian Kurfürst":credits.html#skurfuerst and "Christopher Hlubek":credits.html#hlubek
* November 29, 2011: Greatly expanded version by "Sebastian Kurfürst":credits.html#skurfuerst

