(function (aloha) {
	'use strict';
	
	var Fn = aloha.fn;
	var Dom = aloha.dom;
	var Keys = aloha.keys;
	var Editing = aloha.editing;
	var Boundaries = aloha.boundaries;
	var ACTION_CLASS_PREFIX = 'aloha-action-format-';

	/**
	 * Executes an action object as generated by parseAction() which looks like
	 * one of the following:
	 *
	 * {
	 *    format : 'B'
	 * }
	 *
	 * or even a compound of operations ...
	 *
	 * {
	 *    format     : 'B',
	 *    style      : true,
	 *    styleName  : 'background',
	 *    styleValue : 'red'
	 * }
	 *
	 * @private
	 * @param  {!Object.<string, ?>} action
	 * @param  {!Array.<Boundary>}   boundaries
	 * @return {Array.<Boundaries>}
	 */
	function execute(action, boundaries) {
		if (action.format) {
			boundaries = Editing.format(
				boundaries[0],
				boundaries[1],
				action.format
			);
		}
		if (action.unformat) {
			['B', 'I', 'U'].forEach(function (format) {
				boundaries = Editing.unformat(
					boundaries[0],
					boundaries[1],
					format
				);				
			});
		}
		if (action.style) {
			boundaries = Editing.style(
				boundaries[0],
				boundaries[1],
				action.styleName,
				action.styleValue
			);
		}
		if (action.classes) {
			boundaries = Editing.className(
				boundaries[0],
				boundaries[1],
				action.className
			);
		}
		return boundaries;
	}

	/**
	 * TODO not finished. this is a simplified implementation
	 * as not all actions are formatting actions
	 *
	 * Extracts the intended aloha action from a dom element.
	 * Will look through the classes to find an aloha-action-* class, which is
	 * then transformed into an action object that looks like the following:
	 * { format: true, node: 'b' }
	 *
	 * @private
	 * @param  {!Element} element
	 * @return {?Object}
	 */
	function parseAction(element) {
		var action = {};
		var match;

		Dom.childAndParentsUntil(element, function (element) {
			if (element.className) {
				match = element.className.match(/aloha-action-(\w+)(-(\w+))?/);
			}
			if (match || Dom.hasClass(element, 'aloha-toolbar')) {
				return true;
			} else {
				return false;
			}
		});

		if (match) {
			console.log(match[1], match[3]);
			action[match[1]] = match[3] || true;
		}

		return action;
	}

	/**
	 * Transforms an array of dom nodes into an array of node names
	 * for faster iteration, eg:
	 *
	 * [text, h1, text, p] // array contains DOM nodes
	 *
	 * will return:
	 *
	 * ['P', '#text', 'H1']
	 *
	 * Duplicate entries will be removed, as displayed in the example
	 * above.
	 *
	 * @private
	 * @param {!Array.<Element>} nodes
	 * @return {Array.<string>}
	 */
	function uniqueNodeNames(nodes) {
		var i = nodes.length;
		var arr = [];
		var added = {};
		while (i--) {
			if (!added[nodes[i].nodeName]) {
				arr.push(nodes[i].nodeName);
				added[nodes[i].nodeName] = true;
			}
		}
		return arr;
	}

	/**
	 * Positions the given toolbar element to point to the anchor element in the
	 * document.
	 *
	 * @param  {!Element} toolbar
	 * @param  {!Element} anchor
	 */
	function positionToolbar(toolbar, anchor) {
		var box = aloha.carets.box(Boundaries.range(
			Boundaries.create(anchor, 0),
			Boundaries.create(anchor, 1)
		));
		var center = Math.round(box.left + (box.width / 2));
		var win = Dom.documentWindow(anchor.ownerDocument);
		var windowWidth = win.innerWidth;
		var toolbarWidth = parseInt(Dom.getComputedStyle(toolbar, 'width'), 10);
		var buffer = 10;
		var xMin = buffer;
		var xMax = (windowWidth - toolbarWidth) - buffer;
		var x = Math.min(xMax, Math.max(xMin, center - (toolbarWidth / 2)));
		var y = box.top + box.height + buffer;
		Dom.setStyle(toolbar, 'left', x + 'px');
		Dom.setStyle(toolbar, 'top', y + 'px');
		var arrow = toolbar.querySelector('.aloha-arrow-up');
		var arrowOffset = (x <= xMin || x >= xMax)
		                ? (center - x) + 'px'
		                : 'auto';
		Dom.setStyle(arrow, 'margin-left', arrowOffset);
	}

	function notAnchor(node) { return 'A' !== node.nodeName; }
	function hasClass(className, node) { return Dom.hasClass(node, className); }

	var LinksUI = {

		/**
		 * Opens the given context toolbar for editing the given anchor.
		 *
		 * @param  {!Element} toolbar
		 * @param  {!Element} anchor
		 */
		open: function (toolbar, anchor) {
			$('.aloha-active').removeClass('aloha-active');
			Dom.addClass(anchor, 'aloha-active');
			Dom.addClass(toolbar, 'opened');
			positionToolbar(toolbar, anchor);
			toolbar.querySelector('input').value = Dom.getAttr(anchor, 'href');
		},

		/**
		 * Closes the context toolbar.
		 *
		 * @param  {!Element} toolbar
		 * @param  {!Element} anchor
		 */
		close: function(toolbar, anchor) {
			$('.aloha-active').removeClass('aloha-active');
			Dom.removeClass(toolbar, 'opened');
		},

		/**
		 * Retrieves a toolbar element from the given document if one exists.
		 *
		 * @param  {!Document} doc
		 * @param  {?Element}
		 */
		toolbar: function (doc) {
			var toolbar = doc.querySelector('.aloha-link-toolbar');
			return (toolbar && Dom.hasClass(toolbar.parentNode, 'aloha-3d'))
				 ? toolbar.parentNode
				 : toolbar;
		},

		/**
		 * Returns the element or its first ancestor that has a 'aloha-toolbar'
		 * class, if any.
		 *
		 * @param  {!Element} element
		 * @param  {?Element}
		 */
		closestToolbar: function (element) {
			var toolbar = Dom.upWhile(element, Fn.complement(Fn.partial(hasClass, 'aloha-toolbar')));
			return (toolbar && Dom.hasClass(toolbar.parentNode, 'aloha-3d'))
				 ? toolbar.parentNode
				 : toolbar;
		},

		/**
		 * Handles user interaction on the context toolbar.
		 *
		 * @param  {!Element} element
		 * @param  {!Element} anchor
		 * @param  {!Event}   event
		 */
		interact: function(toolbar, anchor, event) {
			$('a.aloha-active, a.aloha-link-follow').attr('href', toolbar.querySelector('input').value);
			if (Keys.CODES.hash === event.keycode) {
				// TODO dropdown menu of internal headers and anchors
			}
		}

	};

	/**
	 * Links-specific UI handling.
	 *
	 * @param {!Event} event
	 */
	function handleLinks(event) {
		var boundaries = event.boundaries || event.lastEditableBoundaries;
		var cac = Boundaries.commonContainer(boundaries[0], boundaries[1]);
		var anchor = Dom.upWhile(cac, notAnchor);
		var toolbar = LinksUI.toolbar(event.target.ownerDocument);
		if (!toolbar) {
			return;
		}
		if (anchor) {
			return LinksUI.open(toolbar, anchor);
		}
		if (toolbar === LinksUI.closestToolbar(event.target)) {
			return LinksUI.interact(toolbar, anchor, event);
		}
		return LinksUI.close(toolbar, anchor);
	}

	/**
	 * Updates the ui according to current state overrides.
	 *
	 * Sets to active all ui toolbar elements that match the current overrides.
	 *
	 * @private
	 * @param {!Array.<Boundary>} boundries
	 */
	function updateUi(boundaries) {
		var doc = Boundaries.document(boundaries[0]);
		var formatNodes = uniqueNodeNames(Dom.childAndParentsUntilIncl(
			Boundaries.container(boundaries[0]),
			function (node) {
				return node.parentNode && Dom.isEditingHost(node.parentNode);
			}
		));

		/**
		 * Finds the root ul of a bootstrap dropdown menu
		 * starting from an entry node within the menu.
		 * Returns true until the node is found. Meant to
		 * be used with Dom.upWhile().
		 *
		 * @private
		 * @param {!Node} node
		 * @return {boolean}
		 */
		function isDropdownUl(node) {
			return Array.prototype.indexOf.call(node.classList, 'dropdown-menu') === -1;
		}

		Array.prototype.forEach.call(
			doc.querySelectorAll('.aloha-toolbar .active'),
			function (node) {
				Dom.removeClass(node, 'active');
			}
		);

		formatNodes.forEach(function (format) {
			// update buttons
			var buttons = doc.querySelectorAll('.aloha-toolbar .' + ACTION_CLASS_PREFIX + format),
				i = buttons.length;
			while (i--) {
				buttons[i].className += ' active';
			}

			// update dropdowns
			var dropdownEntries = doc
				.querySelectorAll('.aloha-toolbar .dropdown-menu .' + ACTION_CLASS_PREFIX + format),
				dropdownRoot;
			i = dropdownEntries.length;
			var activeDropdowns = doc.querySelectorAll('.aloha-toolbar .dropdown-toggle .active');
			if (activeDropdowns.length > 0) {
				activeDropdowns.forEach(function (node) {
					Dom.removeClass('active');
				});
			}
			if (i > 0) {
				var parents = Dom.parentsUntilIncl(dropdownEntries[0], function (node) {
					return Dom.hasClass(node, 'btn-group');
				});
				var btnGroup = aloha.arrays.last(parents);
				Dom.addClass(btnGroup.querySelector('.dropdown-toggle'), 'active');
			}
			while (i--) {
				dropdownRoot = Dom.upWhile(dropdownEntries[i], isDropdownUl).parentNode;
				dropdownRoot.querySelector('.dropdown-toggle').firstChild.data =
					dropdownEntries[i].innerText + ' ';
			}
		});
	}

	/**
	 * Handles UI updates invoked by event
	 *
	 * @param  {!AlohaEvent} event
	 * @return {AlohaEvent}
	 */
	function handleBootstrapUi(event) {
		var boundaries = event.lastEditableBoundaries;
		if (!boundaries || !('keyup' === event.type || 'click' === event.type)) {
			return event;
		}
		if (Dom.hasClass(event.target, 'aloha-ephemera')) {
			return event;
		}
		var action = parseAction(event.target);
		if (action) {
			event.boundaries = execute(action, boundaries);
		}
		handleLinks(event);
		updateUi(event.boundaries || event.lastEditableBoundaries);
		return event;
	}

	aloha.editor.stack.unshift(handleBootstrapUi);
}(window.aloha));
